// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import {DeploymentKeys} from "@bao-script/deployment/DeploymentKeys.sol";
import {DeploymentLogsTest} from "./DeploymentLogsTest.sol";
import {BaoDeploymentTest} from "./BaoDeploymentTest.sol";
import {MockHarborDeploymentDev} from "./MockHarborDeploymentDev.sol";
import {MintableBurnableERC20_v1} from "@bao/MintableBurnableERC20_v1.sol";

string constant DIRECTORY = "DeploymentJsonPersistenceTest";

/**
 * @title DeploymentJsonPersistenceTest
 * @notice Tests for file persistence functionality
 * @dev Note: "latest" functionality requires vm.readDir() which isn't available in Foundry yet.
 *      These tests verify the save mechanism works without errors.
 */
contract DeploymentJsonPersistenceTest is DeploymentLogsTest {
    function setUp() public {
        _resetDeploymentLogs(DIRECTORY);
    }

    function _newDeployment(string memory filename) internal returns (MockHarborDeploymentDev) {
        MockHarborDeploymentDev deployment = new MockHarborDeploymentDev();

        // Start deployment - this handles file path setup internally
        deployment.start("", "", "");

        // Set custom filename if provided
        deployment.setDir(DIRECTORY);
        deployment.setFilename(filename);

        return deployment;
    }

    function test_BasicFilePersistence() public {
        // Create deployment and set value
        MockHarborDeploymentDev deployment = _newDeployment("BasicFilePersistence");

        deployment.set(deployment.OWNER_KEY(), address(0x1234));
        deployment.setString(deployment.PEGGED_CONFIG_NAME(), "Test Deployment");

        // Files are saved automatically with ISO 8601 timestamps
        // If no errors, save mechanism is working
        assertTrue(true, "File persistence completes without error");
    }

    function test_MultipleWrites() public {
        MockHarborDeploymentDev deployment = _newDeployment("MultipleWrites");

        // Enable sequencing to capture each update phase
        deployment.enableSequencing();

        // Phase 1: Set initial owner
        deployment.setAddress(deployment.OWNER_KEY(), address(0x1111));

        // Phase 2: Add config (owner should be preserved)
        deployment.setAddress(deployment.PEGGED_CONFIG(), address(0xCCCC));

        // Phase 3: Update owner (config should be preserved)
        deployment.setAddress(deployment.OWNER_KEY(), address(0x2222));

        // Phase 4: Add config.name (both owner and config should be preserved)
        deployment.setString(deployment.PEGGED_CONFIG_NAME(), "Test Config");

        // Phase 5: Update owner again (config and config.name should be preserved)
        deployment.setAddress(deployment.OWNER_KEY(), address(0x3333));

        // Verify final state has all fields
        assertEq(deployment.getAddress(deployment.OWNER_KEY()), address(0x3333), "Latest owner not retained");
        assertEq(deployment.getAddress(deployment.PEGGED_CONFIG()), address(0xCCCC), "Config not retained");
        assertEq(deployment.getString(deployment.PEGGED_CONFIG_NAME()), "Test Config", "Config name not retained");
    }

    function test_NetworkIsolation() public {
        // Different networks save to different directories
        MockHarborDeploymentDev deploymentMainnet = _newDeployment("NetworkIsolation");
        deploymentMainnet.setAddress(deploymentMainnet.OWNER_KEY(), address(0xAAAA));

        MockHarborDeploymentDev deploymentArbitrum = _newDeployment("arbitrum", "isolation-test", "first");
        deploymentArbitrum.setAddress(deploymentArbitrum.OWNER_KEY(), address(0xBBBB));

        // Each retains its own value
        assertEq(deploymentMainnet.getAddress(deploymentMainnet.OWNER_KEY()), address(0xAAAA));
        assertEq(deploymentArbitrum.getAddress(deploymentArbitrum.OWNER_KEY()), address(0xBBBB));
    }

    function test_TestingVariantUsesResultsDirectory() public {
        // Verify testing variant creates files under results/
        MockHarborDeploymentDev deployment = _newDeployment("TestingVariantUsesResultsDirectory");

        deployment.setAddress(deployment.OWNER_KEY(), address(0x9999));

        // File should be under the dedicated persistence deployments directory
        // Can't verify exact path without directory listing, but no error means it worked
        assertTrue(true, "Testing variant saves to results/ directory");
    }

    function test_FilenameOverride() public {
        // Test explicit filename setting
        MockHarborDeploymentDev deployment = new MockHarborDeploymentDev();
        deployment.start("persistence-test", "filename-test", "");
        deployment.setFilename("test-deployment-001");

        deployment.setAddress(deployment.OWNER_KEY(), address(0xCCCC));

        // Should save with specified filename
        // Can't verify exact path without directory listing, but no error means it worked
        assertTrue(true, "Custom filename set without error");
    }

    function test_LatestFileFunctionality() public {
        // Create first deployment file
        MockHarborDeploymentDev deployment1 = _newDeployment("persistence-latest-test", "latest-test", "deploy-001");
        deployment1.setAddress(deployment1.OWNER_KEY(), address(0xAAAA));

        // Create second deployment file (different filename)
        MockHarborDeploymentDev deployment2 = _newDeployment("persistence-latest-test", "latest-test", "deploy-002");
        deployment2.setAddress(deployment2.OWNER_KEY(), address(0xBBBB));

        // The "latest" file resolution is handled by Deployment.sol
        // This test just verifies both deployments complete without error
        assertTrue(true, "Multiple deployments complete without error");
    }
}

/**
 * @title DeploymentJsonPersistenceProxyTest
 * @notice Tests proxy deployment workflow with sequenced file persistence
 * @dev Extends BaoDeploymentTest to get deployment infrastructure (BaoDeployer, etc.)
 */
contract DeploymentJsonPersistenceProxyTest is BaoDeploymentTest {
    function test_MultipleWritesWithProxyDeployment() public {
        // This test demonstrates the full deployment workflow across sequenced phases
        // using the actual proxy deployment code path
        MockHarborDeploymentDev harness = new MockHarborDeploymentDev();

        // Start deployment session with sequencing enabled
        harness.start(DIRECTORY, "", "");

        // Enable sequencing to capture each phase
        harness.enableSequencing();

        address admin = makeAddr("admin");

        // Phase 1: Set configuration for first token
        harness.setString(harness.PEGGED_SYMBOL(), "USD");
        harness.setString(harness.PEGGED_NAME(), "Harbor USD");
        harness.setAddress(harness.PEGGED_OWNER(), admin);

        // Phase 2: Deploy proxy using configuration
        address peggedProxy = harness.deployPegged();
        assertNotEq(peggedProxy, address(0), "Proxy should be deployed");

        // Phase 3: Verify deployment metadata was persisted
        assertEq(harness.get(harness.PEGGED()), peggedProxy, "Proxy address should be stored");
        string memory implKey = harness.getString(string.concat(harness.PEGGED(), ".implementation"));
        assertEq(
            implKey,
            string.concat(harness.PEGGED(), "__MintableBurnableERC20_v1"),
            "Implementation key should be stored"
        );

        // Phase 4: Verify proxy works correctly
        MintableBurnableERC20_v1 token = MintableBurnableERC20_v1(peggedProxy);
        assertEq(token.symbol(), "USD", "Symbol should match configuration");
        assertEq(token.name(), "Harbor USD", "Name should match configuration");
        assertEq(token.owner(), address(harness), "Harness should be initial owner");

        // Phase 5: Transfer ownership
        vm.prank(address(harness));
        token.transferOwnership(admin);
        assertEq(token.owner(), admin, "Ownership should be transferred");

        // All phases should be persisted in sequenced files (.001.json through .005.json)
        // Each file shows progression of deployment state
    }
}
