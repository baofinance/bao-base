// SPDX-License-Identifier: MIT
pragma solidity >=0.8.28 <0.9.0;

import {DeploymentRegistryJson} from "@bao-script/deployment/DeploymentDataJson.sol";
import {DeploymentOperatorTesting} from "@bao-script/deployment/DeploymentOperatorTesting.sol";
import {BaoDeployer} from "@bao-script/deployment/BaoDeployer.sol";
import {DeploymentInfrastructure} from "@bao-script/deployment/DeploymentInfrastructure.sol";
import {EfficientHashLib} from "@solady/utils/EfficientHashLib.sol";

/**
 * @title DeploymentFoundryTesting
 * @notice Concrete deployment harness for Foundry tests
 * @dev Combines: DeploymentOperatorTesting (Deployment + operator mixins in one)
 *      Exposes internal methods with public wrappers for test access
 *      Automatically configures BaoDeployer operator when available
 *      Registry saves disabled by default (use enableAutoSave() to generate regression files)
 */
contract DeploymentFoundryTesting is DeploymentOperatorTesting {
    /// @notice Flag to control registry saves in tests
    bool private _registrySavesEnabled;

    /// @notice Constructor for test deployment harness
    /// @dev Registry saves disabled by default to avoid polluting results directory
    constructor() {
        _registrySavesEnabled = false;
    }

    /*//////////////////////////////////////////////////////////////////////////
                            REGISTRY CONTROL
    //////////////////////////////////////////////////////////////////////////*/

    /// @notice Enable registry saves for tests that want to generate regression files
    function enableAutoSave() public {
        _registrySavesEnabled = true;
    }

    /// @notice Disable registry saves (default behavior)
    function disableAutoSave() public {
        _registrySavesEnabled = false;
    }

    /// @notice Override to disable registry saves by default in tests
    /// @dev Tests that want regression files should call enableAutoSave() or use explicit toJsonFile()
    function _saveRegistry() internal virtual override(DeploymentRegistry, DeploymentRegistryJson) {
        if (_registrySavesEnabled) {
            super._saveRegistry();
        }
    }

    /*//////////////////////////////////////////////////////////////////////////
                        TEST-ONLY EXPOSED METHODS
    //////////////////////////////////////////////////////////////////////////*/

    function filepath() public view returns (string memory) {
        return _filepath();
    }

    function forceLoadRegistry(string memory fileName) public {
        _loadRegistry("", fileName);
    }

    function forceSaveRegistry() public {
        super._saveRegistry();
    }

    function toJsonString() public virtual returns (string memory) {
        return _toJson();
    }

    function fromJsonString(string memory json) public {
        _fromJson(json);
    }

    function resumeAfterLoad() public {
        _resumeAfterLoad();
    }

    /// @notice Load deployment state from JSON and immediately resume
    /// @param json Serialized deployment registry (typically produced by toJsonString)
    /// @param network Optional network label override applied to metadata
    function resumeFromJson(string memory json, string memory network) public {
        _fromJson(json);

        if (bytes(network).length != 0 && !_eq(_metadata.network, network)) {
            _metadata.network = network;
        }

        _resumeAfterLoad();
    }

    /// @notice Count how many proxies are still owned by this harness (for testing)
    /// @dev Useful for verifying ownership transfer behavior in tests
    function countTransferrableProxies(address /* newOwner */) public view returns (uint256) {
        uint256 stillOwned = 0;
        string[] memory allKeys = _keys;

        for (uint256 i; i < allKeys.length; i++) {
            string memory key = allKeys[i];

            if (_eq(_entryType[key], "proxy")) {
                address proxy = _proxies[key].info.addr;
                (bool success, bytes memory data) = proxy.staticcall(abi.encodeWithSignature("owner()"));
                if (success && data.length == 32) {
                    address currentOwner = abi.decode(data, (address));
                    if (currentOwner == address(this)) {
                        ++stillOwned;
                    }
                }
            }
        }

        return stillOwned;
    }

    /*//////////////////////////////////////////////////////////////////////////
                        CONTRACT ACCESS WRAPPERS
    //////////////////////////////////////////////////////////////////////////*/

    /**
     * @notice Public wrapper for contract registration
     */
    function registerContract(
        string memory key,
        address addr,
        string memory contractType,
        string memory contractPath,
        string memory category
    ) public {
        return
            _registerStandardContract(
                key,
                addr,
                contractType,
                contractPath,
                category,
                address(0),
                _runs[_runs.length - 1].deployer
            );
    }

    function simulatePredictableDeployWithoutFunding(
        uint256 value,
        string memory key,
        bytes memory initCode,
        string memory /* contractType */,
        string memory /* contractPath */
    ) external virtual returns (address addr) {
        _requireActiveRun();
        if (bytes(key).length == 0) {
            revert KeyRequired();
        }
        if (_exists[key]) {
            revert ContractAlreadyExists(key);
        }

        bytes32 salt = EfficientHashLib.hash(abi.encodePacked(_metadata.systemSaltString, "/", key, "/contract"));
        address baoDeployerAddr = DeploymentInfrastructure.predictBaoDeployerAddress();
        BaoDeployer baoDeployer = BaoDeployer(baoDeployerAddr);
        bytes32 commitment = DeploymentInfrastructure.commitment(address(this), value, salt, keccak256(initCode));
        baoDeployer.commit(commitment);

        addr = baoDeployer.reveal{value: 0}(initCode, salt, value);
    }

    /**
     * @notice Helper for string comparison
     */
    function _strEqual(string memory a, string memory b) private pure returns (bool) {
        return keccak256(bytes(a)) == keccak256(bytes(b));
    }

    /// @notice Compute the derived implementation key for assertions in tests
    function implementationKey(string memory proxyKey, string memory contractType) public pure returns (string memory) {
        return _deriveImplementationKey(proxyKey, contractType);
    }
}
