#!/usr/bin/env bash
#
# Extract BaoFactory bytecode for deterministic deployment
# Generates variant contracts dynamically, compiles them, and extracts bytecode
#
# To add a variant: add entry to VARIANTS array below and run this script
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
OUTPUT_FILE="$PROJECT_ROOT/script/deployment/BaoFactoryBytecode.sol"
VARIANTS_DIR="$PROJECT_ROOT/out/_factory-variants"
VARIANTS_SRC_DIR="$VARIANTS_DIR/src"

cd "$PROJECT_ROOT"

# ============================================================================
# VARIANT CONFIGURATION
# Format: "Name:OwnerAddress"
# - Empty name = production (uses BaoFactory directly)
# - Non-empty name = generates BaoFactory{Name} contract
# ============================================================================
VARIANTS=(
  ":0x9bABfC1A1952a6ed2caC1922BFfE80c0506364a2"             # Production (Harbor multisig)
  "anvil:0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"        # Anvil account 0
  "RootMinus0x1:0x0DC59a2caD3e1fa5D6b8a0F7c1481FcEDFa0bBCA" # rootminus0x1 deployer account
  "chickn:0xAE7Dbb17bc40D53A6363409c6B1ED88d3cFdc31e"       # chickn deployer account
)

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

# Convert variant name to uppercase for constant names
to_upper() {
  echo "$1" | tr '[:lower:]' '[:upper:]'
}

# Get compiler metadata
get_compiler_info() {
  SOLC_VERSION=$(forge config --json | jq -r '.solc // "unknown"')
  OPTIMIZER_RUNS=$(forge config --json | jq -r '.optimizer_runs // "unknown"')
  OPTIMIZER_ENABLED=$(forge config --json | jq -r '.optimizer // false')
  EVM_VERSION=$(forge config --json | jq -r '.evm_version // "unknown"')
}

# ============================================================================
# MAIN SCRIPT
# ============================================================================

echo "=== BaoFactory Bytecode Extraction ==="

# Build production first (needed for base contract import)
echo "Building production BaoFactory..."
forge build --force

# Clean and create variants directory (after forge build since --force cleans out/)
rm -rf "$VARIANTS_DIR"
mkdir -p "$VARIANTS_SRC_DIR"

get_compiler_info
TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")
GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

# Arrays to collect variant data
declare -a VARIANT_NAMES=()
declare -a VARIANT_OWNERS=()
declare -a VARIANT_BYTECODES=()
declare -a VARIANT_HASHES=()

# Process each variant
for variant_entry in "${VARIANTS[@]}"; do
  IFS=':' read -r name owner <<<"$variant_entry"

  if [[ -z "$name" ]]; then
    # Production variant - use existing BaoFactory
    echo "Extracting production BaoFactory bytecode..."
    ARTIFACT="$PROJECT_ROOT/out/BaoFactory.sol/BaoFactory.json"
    CONST_NAME="PRODUCTION"
    VARIANT_NAMES+=("")
    VARIANT_OWNERS+=("$owner")
  else
    # Generated variant - create and compile
    echo "Generating BaoFactory$name variant..."
    CONTRACT_FILE="$VARIANTS_SRC_DIR/BaoFactory${name}.sol"

    cat >"$CONTRACT_FILE" <<SOLEOF
// SPDX-License-Identifier: MIT
// AUTO-GENERATED - DO NOT EDIT
pragma solidity >=0.8.28 <0.9.0;

import {BaoFactoryOwnerless} from "script/deployment/BaoFactory.sol";

contract BaoFactory${name} is BaoFactoryOwnerless {
    address public constant owner = ${owner};

    function _owner() internal pure override returns (address) {
        return owner;
    }
}
SOLEOF

    echo "Compiling BaoFactory$name..."
    forge build --contracts "$CONTRACT_FILE" --out "$VARIANTS_DIR" --skip test --skip script 2>/dev/null || {
      echo "Error: Failed to compile BaoFactory$name"
      exit 1
    }

    ARTIFACT="$VARIANTS_DIR/BaoFactory${name}.sol/BaoFactory${name}.json"
    CONST_NAME=$(to_upper "$name")
    VARIANT_NAMES+=("$name")
    VARIANT_OWNERS+=("$owner")
  fi

  if [[ ! -f "$ARTIFACT" ]]; then
    echo "Error: Artifact not found at $ARTIFACT"
    exit 1
  fi

  # Extract bytecode
  BYTECODE=$(jq -r '.bytecode.object' "$ARTIFACT")
  BYTECODE="${BYTECODE#0x}"
  HASH=$(cast keccak "0x$BYTECODE" | sed 's/0x//')

  VARIANT_BYTECODES+=("$BYTECODE")
  VARIANT_HASHES+=("$HASH")

  echo "  - ${CONST_NAME:-PRODUCTION}: ${#BYTECODE} chars, hash: 0x${HASH:0:16}..."
done

# Verify production bytecode hasn't changed (if file exists)
if [[ -f "$OUTPUT_FILE" ]]; then
  EXISTING_HASH=$(grep -oP 'PRODUCTION_CREATION_CODE_HASH = 0x\K[a-f0-9]+' "$OUTPUT_FILE" 2>/dev/null || echo "")
  if [[ -n "$EXISTING_HASH" && "$EXISTING_HASH" != "${VARIANT_HASHES[0]}" ]]; then
    echo ""
    echo "WARNING: Production bytecode has changed!"
    echo "  Existing hash: 0x$EXISTING_HASH"
    echo "  New hash:      0x${VARIANT_HASHES[0]}"
    echo ""
    echo "This will change the production BaoFactory address."
    echo "If this is intentional, delete the existing BaoFactoryBytecode.sol and re-run."
    exit 1
  fi
fi

# ============================================================================
# GENERATE OUTPUT FILE
# ============================================================================

echo ""
echo "Generating $OUTPUT_FILE..."

cat >"$OUTPUT_FILE" <<EOF
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.28 <0.9.0;

// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// ============================================================================
// Generated: $TIMESTAMP
// Git commit: $GIT_COMMIT
// Compiler: solc $SOLC_VERSION
// Optimizer: $OPTIMIZER_ENABLED (runs: $OPTIMIZER_RUNS)
// EVM version: $EVM_VERSION
// ============================================================================
//
// This file contains bytecode and variant selection for BaoFactory.
// To regenerate: yarn extract-bytecode-baofactory
//
// Variants:
EOF

# Add variant list to header
for i in "${!VARIANT_NAMES[@]}"; do
  name="${VARIANT_NAMES[$i]}"
  owner="${VARIANT_OWNERS[$i]}"
  if [[ -z "$name" ]]; then
    echo "//   - Production (Bao.BaoFactory.v1): $owner" >>"$OUTPUT_FILE"
  else
    echo "//   - $name (Bao.BaoFactory${name}.v1): $owner" >>"$OUTPUT_FILE"
  fi
done

cat >>"$OUTPUT_FILE" <<EOF
// ============================================================================

import {LibClone} from "@solady/utils/LibClone.sol";

/// @title BaoFactoryBytecode
/// @notice Contains captured bytecode and variant selection for BaoFactory deployment
/// @dev Generated bytecode ensures consistent addresses regardless of compiler changes
library BaoFactoryBytecode {
    error UnknownVariant(string variant);

EOF

# Generate bytecode constants for each variant
for i in "${!VARIANT_NAMES[@]}"; do
  name="${VARIANT_NAMES[$i]}"
  bytecode="${VARIANT_BYTECODES[$i]}"
  hash="${VARIANT_HASHES[$i]}"

  if [[ -z "$name" ]]; then
    CONST_NAME="PRODUCTION"
  else
    CONST_NAME=$(to_upper "$name")
  fi

  cat >>"$OUTPUT_FILE" <<EOF
    /// @dev BaoFactory${name} creation code
    bytes internal constant ${CONST_NAME}_CREATION_CODE = hex"$bytecode";

    /// @dev keccak256 of ${CONST_NAME}_CREATION_CODE
    bytes32 internal constant ${CONST_NAME}_CREATION_CODE_HASH = 0x$hash;

EOF
done

# Add ERC1967 proxy constant
cat >>"$OUTPUT_FILE" <<EOF
    /// @dev Solady ERC1967 proxy runtime code hash (61 bytes)
    bytes32 internal constant ERC1967_PROXY_CODE_HASH = LibClone.ERC1967_CODE_HASH;

    /// @notice Get variant configuration from variant string
    /// @dev Production requires exact match "Bao.BaoFactory.v1" or empty string
    ///      Other variants use suffix: "Testing" -> BaoFactoryTesting
    /// @param variant The variant string
    /// @return creationCode The bytecode for this variant
    /// @return factorySalt The salt string for Nick's Factory
    /// @return expectedOwner The expected owner address
    function getVariantConfig(string memory variant)
        internal
        pure
        returns (bytes memory creationCode, string memory factorySalt, address expectedOwner)
    {
        bytes32 h = keccak256(bytes(variant));

        // Production requires exact match "Bao.BaoFactory.v1" or empty
        if (h == keccak256("Bao.BaoFactory.v1") || bytes(variant).length == 0) {
            return (PRODUCTION_CREATION_CODE, "Bao.BaoFactory.v1", ${VARIANT_OWNERS[0]});
        }
EOF

# Generate variant matching for non-production variants
for i in "${!VARIANT_NAMES[@]}"; do
  name="${VARIANT_NAMES[$i]}"
  owner="${VARIANT_OWNERS[$i]}"

  if [[ -n "$name" ]]; then
    CONST_NAME=$(to_upper "$name")
    cat >>"$OUTPUT_FILE" <<EOF

        // $name variant
        if (h == keccak256("$name")) {
            return (${CONST_NAME}_CREATION_CODE, "Bao.BaoFactory${name}.v1", $owner);
        }
EOF
  fi
done

# Close the function and library
cat >>"$OUTPUT_FILE" <<EOF

        revert UnknownVariant(variant);
    }

    /// @notice Get the ERC1967 proxy initcode for a given implementation
    /// @param implementation The implementation address to embed in the proxy
    /// @return initCode The creation code that will deploy a 61-byte ERC1967 proxy
    function proxyInitCode(address implementation) internal pure returns (bytes memory initCode) {
        return LibClone.initCodeERC1967(implementation);
    }
}
EOF

# Clean up generated variant source files (keep artifacts for debugging if needed)
rm -rf "$VARIANTS_SRC_DIR"

echo ""
echo "Done! Generated variants:"
for i in "${!VARIANT_NAMES[@]}"; do
  name="${VARIANT_NAMES[$i]}"
  bytecode="${VARIANT_BYTECODES[$i]}"
  hash="${VARIANT_HASHES[$i]}"
  if [[ -z "$name" ]]; then
    echo "  - Production: ${#bytecode} hex chars ($((${#bytecode} / 2)) bytes), hash: 0x$hash"
  else
    echo "  - $name: ${#bytecode} hex chars ($((${#bytecode} / 2)) bytes), hash: 0x$hash"
  fi
done
echo ""
echo "Output written to: $OUTPUT_FILE"
