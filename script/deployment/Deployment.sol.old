// SPDX-License-Identifier: MIT
pragma solidity >=0.8.28 <0.9.0;

import {CREATE3} from "@solady/utils/CREATE3.sol";
import {EfficientHashLib} from "@solady/utils/EfficientHashLib.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import {IBaoOwnable} from "@bao/interfaces/IBaoOwnable.sol";

import {BaoDeployer} from "@bao-script/deployment/BaoDeployer.sol";
import {DeploymentRegistry} from "@bao-script/deployment/DeploymentRegistry.sol";
import {UUPSProxyDeployStub} from "@bao-script/deployment/UUPSProxyDeployStub.sol";

import {DeploymentInfrastructure} from "@bao-script/deployment/DeploymentInfrastructure.sol";
import {DeploymentConfig} from "@bao-script/deployment/DeploymentConfig.sol";

interface IUUPSUpgradeableProxy {
    function upgradeTo(address newImplementation) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}

/**
 * @title Deployment
 * @notice Deployment operations layer built on top of DeploymentRegistry
 * @dev Responsibilities:
 *      - Deterministic proxy deployment via CREATE3
 *      - Library deployment via CREATE
 *      - Existing contract registration helpers
 *      - Thin wrappers around registry storage helpers
 *      - Designed for specialization (e.g. Harbor overrides deployProxy)
 */
abstract contract Deployment is DeploymentRegistry {
    // ============================================================================
    // Storage
    // ============================================================================

    /// @notice Bootstrap stub used as initial implementation for all proxies
    /// @dev Deployed once per session, owned by this harness, enables BaoOwnable compatibility with CREATE3
    UUPSProxyDeployStub internal _stub;

    // ============================================================================
    // Errors
    // ============================================================================

    error ImplementationKeyRequired();
    error LibraryDeploymentFailed(string key);
    error OwnershipTransferFailed(address proxy);
    error OwnerQueryFailed(address proxy);
    error UnexpectedProxyOwner(address proxy, address owner);
    error FactoryDeploymentFailed(string reason);
    error ValueMismatch(uint256 expected, uint256 received);
    error ConfigSchemaMismatch(uint256 expected, uint256 actual);
    error ConfigOwnerMismatch(address expected, address actual);
    error ConfigVersionMismatch(string expected, string actual);
    error ConfigNetworkMismatch(string expected, string actual);
    error ConfigSaltMismatch(string expected, string actual);
    error ConfigSystemSaltMissing();

    // ============================================================================
    // Factory Abstraction
    // ============================================================================

    /// @notice Get the deployer address for CREATE3 operations
    /// @dev Returns BaoDeployer address - same on all chains (deployed via Nick's Factory)
    ///      This is used for both prediction and deployment
    /// @return deployer BaoDeployer contract address
    function _getCreate3Deployer() internal view virtual returns (address deployer) {
        deployer = DeploymentInfrastructure.predictBaoDeployerAddress();
        if (deployer == address(0)) {
            revert FactoryDeploymentFailed("BaoDeployer owner not configured");
        }
    }

    /// @notice Require that this deployment harness is configured as BaoDeployer operator
    /// @dev Production check - reverts if operator not already configured by multisig
    ///      Testing classes override this to auto-setup operator via VM.prank
    function _requireBaoDeployerOperator() internal virtual {
        address baoDeployer = DeploymentInfrastructure.predictBaoDeployerAddress();
        if (baoDeployer.code.length == 0) {
            revert FactoryDeploymentFailed("BaoDeployer missing code");
        }
        if (BaoDeployer(baoDeployer).operator() != address(this)) {
            revert FactoryDeploymentFailed("BaoDeployer operator not configured for harness");
        }
    }

    // ============================================================================
    // Deployment Lifecycle
    // ============================================================================

    /// @notice Start a fresh deployment session from JSON config
    /// @param jsonConfig Deployment configuration JSON string
    /// @param network Network label used for deployment logs
    function start(string memory jsonConfig, string memory network) public virtual {
        DeploymentConfig.SourceJson memory config = DeploymentConfig.fromJson(jsonConfig);
        start(config, network);
    }

    /// @notice Start a fresh deployment session from a parsed config
    /// @param config Parsed deployment configuration
    /// @param network Network label used for deployment logs
    function start(DeploymentConfig.SourceJson memory config, string memory network) public virtual {
        address owner = DeploymentConfig.get(config, "", "owner");
        string memory version = DeploymentConfig.getString(config, "", "version");

        if (DeploymentConfig.has(config, "", "schemaVersion")) {
            uint256 configSchema = DeploymentConfig.getUint(config, "", "schemaVersion");
            if (configSchema != DEPLOYMENT_SCHEMA_VERSION) {
                revert ConfigSchemaMismatch(DEPLOYMENT_SCHEMA_VERSION, configSchema);
            }
        }

        string memory systemSaltString = _deriveSystemSalt(config);
        if (_metadata.startTimestamp != 0) {
            revert AlreadyInitialized();
        }
        require(_runs.length == 0, "Cannot start: runs already exist");

        _schemaVersion = DEPLOYMENT_SCHEMA_VERSION;
        _metadata.deployer = address(this);
        _metadata.owner = owner;
        _metadata.startTimestamp = block.timestamp;
        _metadata.startBlock = block.number;
        _metadata.network = network;
        _metadata.version = version;
        _metadata.systemSaltString = systemSaltString;
        _metadata.finishTimestamp = 0;
        _metadata.finishBlock = 0;

        _runs.push(
            RunRecord({
                deployer: address(this),
                startTimestamp: block.timestamp,
                finishTimestamp: 0,
                startBlock: block.number,
                finishBlock: 0,
                finished: false
            })
        );
        _saveRegistry();

        require(DeploymentInfrastructure.predictBaoDeployerAddress().code.length > 0, "need to deploy the BaoDeployer");
        _requireBaoDeployerOperator();

        _stub = new UUPSProxyDeployStub();

        _registerConfigParameters(config);
    }
    function ensureBaoDeployer() public returns (address deployed) {
        deployed = DeploymentInfrastructure.ensureBaoDeployer();
        if (_runs.length > 0 && !_exists["BaoDeployer"]) {
            useExisting("BaoDeployer", deployed);
        }
    }

    /// @notice Resume deployment from JSON config
    /// @param jsonConfig Deployment configuration JSON string
    /// @param network Network label used for deployment logs
    function resume(string memory jsonConfig, string memory network) public virtual {
        DeploymentConfig.SourceJson memory config = DeploymentConfig.fromJson(jsonConfig);
        resume(config, network);
    }

    /// @notice Resume deployment from parsed config
    /// @param config Parsed deployment configuration
    function resume(DeploymentConfig.SourceJson memory config, string memory network) public virtual {
        string memory systemSaltString = _deriveSystemSalt(config);
        _loadRegistry(network, systemSaltString);

        if (_schemaVersion != DEPLOYMENT_SCHEMA_VERSION) {
            revert ConfigSchemaMismatch(DEPLOYMENT_SCHEMA_VERSION, _schemaVersion);
        }

        address configOwner = DeploymentConfig.get(config, "", "owner");
        string memory configVersion = DeploymentConfig.getString(config, "", "version");

        if (_metadata.owner != configOwner) {
            revert ConfigOwnerMismatch(configOwner, _metadata.owner);
        }
        if (!_eq(_metadata.version, configVersion)) {
            revert ConfigVersionMismatch(configVersion, _metadata.version);
        }

        if (!_eq(_metadata.systemSaltString, systemSaltString)) {
            revert ConfigSaltMismatch(systemSaltString, _metadata.systemSaltString);
        }

        if (bytes(network).length != 0 && !_eq(_metadata.network, network)) {
            revert ConfigNetworkMismatch(_metadata.network, network);
        }
        if (bytes(network).length != 0) {
            _metadata.network = network;
        }

        _resumeAfterLoad();

        _registerConfigParameters(config);
    }

    /// @notice Derive the system salt string from configuration data
    /// @dev Default implementation expects `systemSaltString` at the top level of the config
    function _deriveSystemSalt(
        DeploymentConfig.SourceJson memory config
    ) internal view virtual returns (string memory) {
        if (DeploymentConfig.has(config, "", "systemSaltString")) {
            return DeploymentConfig.getString(config, "", "systemSaltString");
        }

        revert ConfigSystemSaltMissing();
    }

    function _resumeAfterLoad() internal {
        // Validate runs for resume
        require(_runs.length >= 1, "Cannot resume: no runs in deployment");
        require(_runs[_runs.length - 1].finished, "Cannot resume: last run not finished");

        // Create new run record for this resume session
        _runs.push(
            RunRecord({
                deployer: address(this),
                startTimestamp: block.timestamp,
                finishTimestamp: 0,
                startBlock: block.number,
                finishBlock: 0,
                finished: false
            })
        );
        _saveRegistry();

        _requireBaoDeployerOperator();
        _stub = new UUPSProxyDeployStub();
    }

    /// @notice Finish deployment session and finalize ownership
    /// @dev Transfers ownership to metadata.owner for all proxies currently owned by this harness
    /// @dev Records run in audit trail and updates finishTimestamp timestamp
    /// @return transferred Number of proxies whose ownership was transferred
    function finish() public virtual returns (uint256 transferred) {
        address owner = _metadata.owner;
        string[] memory allKeys = _keys;
        uint256 length = allKeys.length;

        for (uint256 i; i < length; i++) {
            string memory key = allKeys[i];

            if (_eq(_entryType[key], "proxy")) {
                if (_resumedProxies[key]) {
                    continue;
                }

                address proxy = _proxies[key].info.addr;

                // Check if proxy supports owner() method (BaoOwnable pattern)
                (bool success, bytes memory data) = proxy.staticcall(abi.encodeWithSignature("owner()"));
                if (!success || data.length != 32) {
                    // Contract doesn't support BaoOwnable, skip
                    continue;
                }

                address currentOwner = abi.decode(data, (address));

                // Only transfer if current owner is this harness (temporary owner from stub pattern)
                if (currentOwner == address(this)) {
                    IBaoOwnable(proxy).transferOwnership(owner);
                    ++transferred;
                }
            }
        }

        // Mark current run as finished
        require(_runs.length > 0, "No run to finish");
        require(!_runs[_runs.length - 1].finished, "Run already finished");

        _runs[_runs.length - 1].finishTimestamp = block.timestamp;
        _runs[_runs.length - 1].finishBlock = block.number;
        _runs[_runs.length - 1].finished = true;

        // Update metadata timestamps from last run
        _metadata.finishTimestamp = block.timestamp;
        _metadata.finishBlock = block.number;

        _saveRegistry();
        return transferred;
    }

    // ============================================================================
    // Exposed views
    // ============================================================================

    function getSystemSaltString() public view returns (string memory) {
        return _metadata.systemSaltString;
    }

    // ============================================================================
    // Proxy Deployment / Upgrades
    // ============================================================================

    /// @notice Predict proxy address without deploying
    /// @param proxyKey Key for the proxy deployment
    /// @return proxy Predicted proxy address
    function predictProxyAddress(string memory proxyKey) public view returns (address proxy) {
        if (bytes(proxyKey).length == 0) {
            revert KeyRequired();
        }
        bytes memory proxySaltBytes = abi.encodePacked(_metadata.systemSaltString, "/", proxyKey, "/UUPS/proxy");
        bytes32 salt = EfficientHashLib.hash(proxySaltBytes);
        address deployer = _getCreate3Deployer();
        proxy = CREATE3.predictDeterministicAddress(salt, deployer);
    }
    function deployProxy(
        uint256 value,
        string memory proxyKey,
        string memory implementationKey,
        bytes memory implementationInitData
    ) external payable virtual returns (address proxy) {
        if (msg.value != value) {
            revert ValueMismatch(value, msg.value);
        }
        proxy = _deployProxy(value, proxyKey, implementationKey, implementationInitData);
    }

    /// @notice Deploy a UUPS proxy using bootstrap stub pattern
    /// @dev Three-step process:
    ///      1. Deploy ERC1967Proxy via CREATE3 pointing to stub (no initialization)
    ///      2. Call proxy.upgradeToAndCall(implementation, initData) to atomically upgrade and initialize
    ///      During initialization, msg.sender = this harness (via stub ownership), enabling BaoOwnable compatibility
    /// @param proxyKey Key for the proxy deployment
    /// @param implementationKey Key of the implementation to use
    /// @param implementationInitData Initialization data to pass to implementation (includes owner if needed)
    /// @return proxy The deployed proxy address
    function deployProxy(
        string memory proxyKey,
        string memory implementationKey,
        bytes memory implementationInitData
    ) external virtual returns (address proxy) {
        proxy = _deployProxy(0, proxyKey, implementationKey, implementationInitData);
    }

    function predictableDeployContract(
        uint256 value,
        string memory key,
        bytes memory initCode,
        string memory contractType,
        string memory contractPath
    ) external payable virtual returns (address addr) {
        if (msg.value != value) {
            revert ValueMismatch(value, msg.value);
        }
        return _predictableDeployContract(value, key, initCode, contractType, contractPath);
    }

    function predictableDeployContract(
        string memory key,
        bytes memory initCode,
        string memory contractType,
        string memory contractPath
    ) external virtual returns (address addr) {
        return _predictableDeployContract(0, key, initCode, contractType, contractPath);
    }

    function _predictableDeployContract(
        uint256 value,
        string memory key,
        bytes memory initCode,
        string memory contractType,
        string memory contractPath
    ) internal virtual returns (address addr) {
        _requireActiveRun();
        if (bytes(key).length == 0) {
            revert KeyRequired();
        }
        if (_exists[key]) {
            revert ContractAlreadyExists(key);
        }

        // Compute salt
        bytes32 salt = EfficientHashLib.hash(abi.encodePacked(_metadata.systemSaltString, "/", key, "/contract"));

        // commit-reveal via to avoid front-running the deployment which could steal our address
        address baoDeployerAddr = DeploymentInfrastructure.predictBaoDeployerAddress();
        BaoDeployer baoDeployer = BaoDeployer(baoDeployerAddr);
        baoDeployer.commit(DeploymentInfrastructure.commitment(address(this), value, salt, keccak256(initCode)));
        addr = baoDeployer.reveal{value: value}(initCode, salt, value);

        _registerStandardContract(
            key,
            addr,
            contractType,
            contractPath,
            "contract",
            baoDeployerAddr,
            _runs[_runs.length - 1].deployer
        );

        emit ContractDeployed(key, addr, "contract");
        return addr;
    }

    // =========================================================================
    // Config Parameter Registration
    // =========================================================================

    function _registerConfigParameters(DeploymentConfig.SourceJson memory config) internal virtual {
        _registerConfigParameters(config, "", "$");
    }

    function _registerConfigParameters(
        DeploymentConfig.SourceJson memory config,
        string memory keyPrefix,
        string memory pointer
    ) internal virtual {
        if (bytes(pointer).length == 0) {
            return;
        }

        if (bytes(keyPrefix).length != 0 && _shouldSkipConfigParameterKey(keyPrefix)) {
            return;
        }

        (bool hasChildren, string[] memory childKeys) = DeploymentConfig.listObjectKeys(config, pointer);
        if (hasChildren && childKeys.length > 0) {
            for (uint256 i = 0; i < childKeys.length; i++) {
                string memory childKey = childKeys[i];
                string memory nestedKey = _joinConfigParameterKey(keyPrefix, childKey);
                string memory nestedPointer = _appendPointer(pointer, childKey);
                _registerConfigParameters(config, nestedKey, nestedPointer);
            }
            return;
        }

        if (_hasArrayEntries(config, pointer)) {
            uint256 index;
            while (DeploymentConfig.hasArrayEntry(config, pointer, index)) {
                string memory indexString = _uintToString(index);
                string memory nestedKey = _joinConfigParameterKey(keyPrefix, indexString);
                string memory nestedPointer = string.concat(pointer, "[", indexString, "]");
                _registerConfigParameters(config, nestedKey, nestedPointer);
                unchecked {
                    ++index;
                }
            }
            return;
        }

        _registerScalarConfigParameter(config, keyPrefix, pointer);
    }

    function _registerScalarConfigParameter(
        DeploymentConfig.SourceJson memory config,
        string memory key,
        string memory pointer
    ) internal {
        if (bytes(key).length == 0) {
            return;
        }
        if (_shouldSkipConfigParameterKey(key)) {
            return;
        }
        if (_exists[key]) {
            return;
        }

        (bool boolSuccess, bool boolValue) = DeploymentConfig.tryReadBool(config, pointer);
        if (boolSuccess) {
            setBool(key, boolValue);
            return;
        }

        (bool stringSuccess, string memory stringValue) = DeploymentConfig.tryReadString(config, pointer);
        if (stringSuccess && _looksLikeHexAddress(stringValue)) {
            setString(key, stringValue);
            return;
        }

        (bool intSuccess, int256 intValue) = DeploymentConfig.tryReadInt(config, pointer);
        (bool uintSuccess, uint256 uintValue) = DeploymentConfig.tryReadUint(config, pointer);
        if (intSuccess || uintSuccess) {
            _setNumberParameter(key, uintSuccess, uintValue, intSuccess, intValue);
            return;
        }

        if (stringSuccess) {
            setString(key, stringValue);
        }
    }

    function _joinConfigParameterKey(string memory prefix, string memory child) private pure returns (string memory) {
        if (bytes(prefix).length == 0) {
            return child;
        }
        if (bytes(child).length == 0) {
            return prefix;
        }
        return string.concat(prefix, ".", child);
    }

    function _appendPointer(string memory pointer, string memory child) private pure returns (string memory) {
        if (bytes(child).length == 0) {
            return pointer;
        }
        if (bytes(pointer).length == 0) {
            return child;
        }

        bytes memory pointerBytes = bytes(pointer);
        if (pointerBytes.length == 1 && pointerBytes[0] == bytes1("$")) {
            return string.concat(pointer, ".", child);
        }
        return string.concat(pointer, ".", child);
    }

    function _hasArrayEntries(
        DeploymentConfig.SourceJson memory config,
        string memory pointer
    ) private view returns (bool) {
        return DeploymentConfig.hasArrayEntry(config, pointer, 0);
    }

    function _shouldSkipConfigParameterKey(string memory key) private pure returns (bool) {
        bytes memory data = bytes(key);
        if (data.length == 0) {
            return true;
        }
        if (_containsDot(data)) {
            return false;
        }

        bytes32 keyHash = keccak256(data);
        if (
            keyHash == keccak256(bytes("owner")) ||
            keyHash == keccak256(bytes("treasury")) ||
            keyHash == keccak256(bytes("version")) ||
            keyHash == keccak256(bytes("network")) ||
            keyHash == keccak256(bytes("systemSaltString")) ||
            keyHash == keccak256(bytes("schemaVersion")) ||
            keyHash == keccak256(bytes("conflicts")) ||
            keyHash == keccak256(bytes("contracts"))
        ) {
            return true;
        }

        return false;
    }

    function _containsDot(bytes memory data) private pure returns (bool) {
        for (uint256 i = 0; i < data.length; i++) {
            if (data[i] == bytes1(".")) {
                return true;
            }
        }
        return false;
    }

    function _looksLikeHexAddress(string memory value) private pure returns (bool) {
        bytes memory data = bytes(value);
        if (data.length != 42) {
            return false;
        }
        if (data[0] != bytes1("0")) {
            return false;
        }
        bytes1 prefix = data[1];
        if (prefix != bytes1("x") && prefix != bytes1("X")) {
            return false;
        }
        for (uint256 i = 2; i < data.length; i++) {
            bytes1 char = data[i];
            bool isDigit = char >= bytes1("0") && char <= bytes1("9");
            bool isLower = char >= bytes1("a") && char <= bytes1("f");
            bool isUpper = char >= bytes1("A") && char <= bytes1("F");
            if (!isDigit && !isLower && !isUpper) {
                return false;
            }
        }
        return true;
    }

    function _uintToString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0";
        }

        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }

        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits--;
            buffer[digits] = bytes1(uint8(48 + (value % 10)));
            value /= 10;
        }

        return string(buffer);
    }

    function _deployProxy(
        uint256 value,
        string memory proxyKey,
        string memory implementationKey,
        bytes memory implementationInitData
    ) internal virtual returns (address proxy) {
        _requireActiveRun();
        if (bytes(proxyKey).length == 0) {
            revert KeyRequired();
        }
        if (_exists[proxyKey]) {
            revert ContractAlreadyExists(proxyKey);
        }
        address implementation = get(implementationKey);
        if (!_exists[implementationKey] || !_eq(_entryType[implementationKey], "implementation")) {
            revert ImplementationKeyRequired();
        }

        // Compute salt
        bytes memory proxySaltBytes = abi.encodePacked(_metadata.systemSaltString, "/", proxyKey, "/UUPS/proxy");
        bytes32 salt = EfficientHashLib.hash(proxySaltBytes);
        string memory saltString = proxyKey;

        address factory = DeploymentInfrastructure.predictBaoDeployerAddress();

        bytes memory proxyCreationCode = abi.encodePacked(
            type(ERC1967Proxy).creationCode,
            abi.encode(address(_stub), bytes(""))
        );

        BaoDeployer deployer = BaoDeployer(factory);
        bytes32 commitment = DeploymentInfrastructure.commitment(
            address(this),
            0,
            salt,
            EfficientHashLib.hash(proxyCreationCode)
        );
        deployer.commit(commitment);
        proxy = deployer.reveal(proxyCreationCode, salt, 0);

        if (value == 0) {
            IUUPSUpgradeableProxy(proxy).upgradeToAndCall(implementation, implementationInitData);
        } else {
            IUUPSUpgradeableProxy(proxy).upgradeToAndCall{value: value}(implementation, implementationInitData);
        }

        // Register proxy (same for both dry-run and actual deployment)
        _registerProxy(
            proxyKey,
            proxy,
            implementationKey,
            salt,
            saltString,
            "UUPS",
            factory,
            _runs[_runs.length - 1].deployer
        );

        emit ContractDeployed(proxyKey, proxy, "UUPS proxy");
    }

    function upgradeProxy(
        string memory proxyKey,
        string memory newImplementationKey,
        bytes memory initData
    ) external virtual {
        if (bytes(proxyKey).length == 0 || bytes(newImplementationKey).length == 0) {
            revert KeyRequired();
        }
        address proxy = _getProxy(proxyKey);
        address newImplementation = _getImplementation(newImplementationKey);

        if (initData.length == 0) {
            IUUPSUpgradeableProxy(proxy).upgradeTo(newImplementation);
        } else {
            IUUPSUpgradeableProxy(proxy).upgradeToAndCall(newImplementation, initData);
        }

        // Update registry to reflect the new implementation
        _updateProxyImplementation(proxyKey, newImplementationKey);

        emit ContractUpdated(proxyKey, proxy, proxy);
    }

    function useExisting(string memory key, address addr) public virtual {
        _registerStandardContract(key, addr, "ExistingContract", "blockchain", "existing", address(0), address(0));
    }

    /**
     * @notice Register implementation with key derived from proxy key and contract type
     * @dev Implementation key pattern: proxyKey__contractType
     *      This ensures consistent implementation key generation across all deployers
     * @param proxyKey The proxy key this implementation is for
     * @param addr Implementation contract address
     * @param contractType Contract type name (used in key derivation)
     * @param contractPath Source file path
     * @return implKey The derived implementation key (proxyKey__contractType)
     */
    function registerImplementation(
        string memory proxyKey,
        address addr,
        string memory contractType,
        string memory contractPath
    ) public virtual returns (string memory implKey) {
        _requireActiveRun();
        implKey = _deriveImplementationKey(proxyKey, contractType);
        _requireValidAddress(implKey, addr);
        _registerImplementation(implKey, addr, contractType, contractPath, _runs[_runs.length - 1].deployer);
        emit ContractDeployed(implKey, addr, "implementation");
    }

    /// @notice Derive the canonical implementation key for a proxy key and contract type
    function _deriveImplementationKey(
        string memory proxyKey,
        string memory contractType
    ) internal pure returns (string memory) {
        return string.concat(proxyKey, "__", contractType);
    }

    function deployLibrary(
        string memory key,
        bytes memory bytecode,
        string memory contractType,
        string memory contractPath
    ) public {
        _requireActiveRun();

        address addr;
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
        }
        if (addr == address(0)) {
            revert LibraryDeploymentFailed(key);
        }

        _registerLibrary(key, addr, contractType, contractPath, _runs[_runs.length - 1].deployer);
        emit ContractDeployed(key, addr, "library");
    }
}
