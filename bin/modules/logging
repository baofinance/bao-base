#!/bin/bash

#if [[ -n "${GUARD_SOURCING_$(echo "$(basename "$0")" | tr -c '[:alnum:]' '_'):-}" ]]; then return; fi; GUARD_SOURCING_GUARD_SOURCING_$(echo "$(basename "$0")" | tr -c '[:alnum:]' '_')=1
if [[ -n "${GUARD_SOURCING_LOGGING:-}" ]]; then return; fi; GUARD_SOURCING_LOGGING=1
echo "loading 'logging' from ${BASH_SOURCE[1]}"

# set the default logging level to warn (and above)
LOGGING_LEVEL=${LOGGING_LEVEL:-2}
# set the default output FD, this is changed to 8 below so logging doesn't clog things up
_logging_file_descriptor=2

logging_config() {
    LOGGING_LEVEL=$(_logging_to_value "$1")
    logging $1 "logging level is now $1"
}

logging() {
    local level_str=$(echo "$1" | tr '[:lower:]' '[:upper:]')
    local level=$(_logging_to_value "$1")
    shift
    local message="$*"
    # TODO: automatic indentation via $#BASH_SOURCE
    if [[ "$level" -ge "$LOGGING_LEVEL" ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S,%3N') - ${BASH_SOURCE[1]}:${BASH_LINENO[0]} ${FUNCNAME[1]}(): $(printf "%-6s" "$level_str:") $message" >&$_logging_file_descriptor
    fi
    if [[ "$level" -ge "4" ]]; then
        exit 1
    fi
 }

_logging_to_value() {
    local level=0
    case $(echo "$1" | tr '[:upper:]' '[:lower:]') in
        debug ) level=0
                ;;
        info  ) level=1
                ;;
        warn  ) level=2
                ;;
        error ) level=3
                ;;
        fail  ) level=4
                ;;
    esac
    echo $level
}

# use file descriptor 8 (3-9 are available) for logging output, fail if it is already in use
# TODO: make this number configurable (somehow?), or search for the first free one
# as it is just sent to stdout, without buffering
# as we're only opening it once, there is no need to close it

if lsof -p $$ 2>/dev/null | awk '{print $4}' | grep -q '^8'; then
    logging fail "File descriptor 8 is in use"
else
    _logging_file_descriptor=8
    #exec 8> >(stdbuf -o0 cat)
    exec 8>&1

fi