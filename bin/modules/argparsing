#!/bin/bash

if [[ -n "${GUARD_SOURCING_ARGPARSING:-}" ]]; then return; fi; GUARD_SOURCING_ARGPARSING=1

source $(dirname "${BASH_SOURCE[0]}")/logging

######################################
# JSON args / command line conversion
######################################

# convert a command line to JSON args
argparsing_argparse() {
    logging debug "$FUNCNAME($*)..."
    # run the python argparse wrapper from the same directory
    # remove the null values. need to pass it through jq -c anyway
    local output=$($(dirname "${BASH_SOURCE[0]}")/wargparse.py "$@")
    logging debug "wargparse.py->'$output'"
    output=$(echo "$output" | jq -rc '.known |= with_entries(select(.value.value != null))')
    logging debug "$FUNCNAME->'$output'"
    echo "$output"
}


# convert a JSON args to a command line
argparsing_args() {
    logging debug "$FUNCNAME($*)..."
    local json_args="$1"
    shift
    local args=("$@")
    # default to outputting both known and unknown, in that order
    if [ ${#args[@]} -eq 0 ]; then args=( "known" "unknown" ); fi

    local known=0   # to stop duplicate output of known data
    local unknown=0 # to stop duplicate output of unknown data
    local output="" # build up a string
    for arg in "${args[@]}"; do
        local this_output=""
        case "$arg" in
        known)
            if [ $known -eq 0 ]; then
                known=1
                # logging debug "processing knowns..."
                this_output=$(jq -r '
                    if .known then
                        .known
                        | to_entries
                        | map(select(.value.value != null))
                        | map((if .value.origin != null then (.value.origin + " ") else "" end) + "'\''" + .value.value + "'\''")
                        | join(" ")
                    else
                        ""
                    end
                ' <<< "$json_args" )
            fi
            ;;
        unknown)
            if [ $unknown -eq 0 ]; then
                unknown=1
                this_output=$(jq -r '
                    if .unknown then
                        .unknown
                        | map(
                            if test("^-") then .
                            else ("'\''" + . + "'\''")
                            end
                        )
                        | join(" ")
                    else
                        ""
                    end
                ' <<< "$json_args")
            fi
            ;;
        *)
            logging fail "filter must be either 'known' or 'unknown' or both"
            break
            ;;
        esac
        # logging debug "this_output='$this_output'"
        if [ "${#this_output}" -gt 0 ]; then
            output="$output $this_output"
        fi
    done
    logging debug "$FUNCNAME->'$output'"
    echo -n "$output"
}

#######################
# JSON args processing
#######################


# delete the complete set of unknown args
argparsing_remove_unknown() {
    logging debug "$FUNCNAME($*)..."
    local json_args="$1"
    local output=$(jq -rc '.unknown |= []' <<< "$json_args")
    logging debug "$FUNCNAME->'$output'"
    echo "$output"
}

# does a field exist - give a known field name (e.g. something with names:[--rpc-url] is rpc_url)
argparsing_has() {
    logging debug "$FUNCNAME($*)..."
    local json_args="$1"
    local dest="$2"
    local value=$(jq -rc "getpath([\"known\", \"$dest\"]) != null" <<< "$json_args")
    logging debug "$FUNCNAME->'$value'"
    [[ "$value" == "true" ]] && return 0
    return 1
}

argparsing_option() {
    logging debug "$FUNCNAME($*)..."
    local json_args="$1"
    local dest="$2"
    local value=$(jq -rc ".known.$dest.value // \"\"" <<< "$json_args")
    logging debug "$FUNCNAME->'$value'"
    echo "$value"
}

argparsing_positional() {
    logging debug "$FUNCNAME($*)..."
    local json_args="$1"
    local pos="$2"
    local value=$(jq -rc ".unknown[$pos] // \"\"" <<< "$json_args")
    logging debug "$FUNCNAME->'$value'"
    echo "$value"
}

argparsing_add() {
    logging debug "$FUNCNAME($*)..."
    local json_args="$1"
    local key="$2"
    local value="$3"
    local origin="$4"
    local output=$(jq -rc ".known.$key = {value: \"$value\", origin: \"$origin\"}" <<< "$json_args")
    logging debug "$FUNCNAME->'$output'"
    echo "$output"
}

# takes two JSON args and merges them prioritising the second argument
argparsing_merge() {
    logging debug "$FUNCNAME($*)..."
    local defaults="$1"
    local overrides="$2"
    logging debug "default='$defaults'"
    logging debug "overrides='$overrides'"
    # merge knowns overriding from the right
    # unknowns take from the right, even if it's empty
    local output=$(jq -cs '{
        known: ((.[0].known + .[1].known) // []),
        unknown: (.[1].unknown // [])
        }' <(echo "$defaults") <(echo "$overrides"))
    logging debug "$FUNCNAME->'$output'"
    echo "$output"
}

# takes two JSON args and returns those fields in both, order defined by the first argument
argparsing_intersection() {
    logging debug "$FUNCNAME($*)..."
    local a="$1"
    local b="$2"

    local output=$(jq -sc '.[0] as $a | .[1] as $b |
        {
            known: (
            $a.known
            | to_entries
            | map(select($b.known[.key] != null))
            | from_entries
            ),
            unknown: (
            $a.unknown
            | map(select(. as $item | $b.unknown | index($item) != null))
            )
        }' <(echo "$a") <(echo "$b"))
    logging debug "$FUNCNAME->'$output'"
    echo "$output"
}

# argparsing_extract_getopt_spec_from_hashhash() {
#     local spec_file="${1:-${BASH_SOURCE[1]}}" # default to calling script, not this one
#     local short=""
#     local long=""

#     while IFS= read -r line; do
#         # Only process lines that start with '##', have spaces, then a '-'
#         [[ ! "$line" =~ ^##[[:space:]]+- ]] && continue

#         # TODO: if the line doesn't have two spaces then treat the whole line as an option-spec
#         # Ensure the line contains at least two spaces, separating the documentation
#         if [[ "$line" =~ [[:space:]]{2,} ]]; then
#             # Remove the leading `##` and extract only the option spec
#             clean_line=$(sed -E 's/^##[[:space:]]+//; s/[[:space:]]{2,}.*//g' <<< "$line")

#             # extract the option names and values, passing them out
#             local count=0

#             # Define regex patterns
#             local regex_option="-[[:alnum:]_-]+"
#             local regex_options="(^[[:space:]]*$regex_option([[:space:]]*,[[:space:]]*$regex_option)*)"
#             # parse the options as a comma separated list
#             if [[ ! "$clean_line" =~ $regex_options ]]; then
#                 logging fail "Failed to extract options from: '$clean_line'"
#             fi

#             local options_match=${BASH_REMATCH[1]} # match the comma separated list
#             local values_match="${clean_line:${#options_match}}" # everything after
#             # logging debug "options_match=$options_match"
#             # logging debug "values_match=$values_match"

#             # n n - v1 v2 v3
#             # n 8 - v1 v2...
#             # 2 5 - v1 v2 [v3 v4 v5]
#             # 2 8 - v2 v2 [v1 v2...]
#             # min is just the word count of everything up to [
#             local min_args=$(echo "${values_match%%[*}" | wc -w)

#             # max is the word count of all words (ignoring [ and ]) unless there is a ..., when it is infinite
#             local max_args=-1
#             if [[ ! $values_match == *"..."* ]]; then
#                 max_args=$(echo "${values_match//[\[\].]/}" | wc -w)
#             fi

#             # translate the min/max_args into getopt style colons
#             # : exactly one arg expected
#             # :: zero-or-one arg expected
#             # '' no arg expected
#             # if max_args is > 1 then it's ignored
#             local arg_spec=''
#             if [[ "$max_args" -ge 1 ]]; then
#                 arg_spec=':'
#                 if [[ "$min_args" == "0" ]]; then
#                     arg_spec='::'
#                 fi
#             fi

#             IFS=',' read -ra options <<< "$options_match"
#             for option in "${options[@]}"; do
#                 logging debug "option=$option"
#                 if [[ "$option" =~ ^[[:space:]]*(--?)([^[:space:]]+)[[:space:]]*$ ]]; then
#                     word="${BASH_REMATCH[2]}"
#                     if [[ "${BASH_REMATCH[1]}" == "-" ]]; then
#                         if [[ ${#word} -ne 1 ]]; then
#                             logging fail "short form (single leading hyphen) option must only have a single letter: '$word'"
#                         fi
#                         short+="$word$arg_spec"
#                     else
#                         long="${long:+$long,}$word$arg_spec"
#                     fi
#                 else
#                     logging fail "## option spec did not match the expected pattern: -[-]word"
#                 fi
#             done
#         else
#             logging fail "Invalid format or missing documentation in line: '$line'"
#         fi
#     done < "$spec_file"

#     echo "-o ${short:-''} ${long:+-l $long}"
# }
