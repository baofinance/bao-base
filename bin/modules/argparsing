#!/bin/bash

if [[ -n "${GUARD_SOURCING_ARGPARSING:-}" ]]; then return; fi; export GUARD_SOURCING_ARGPARSING=1

source lib/bao-base/bin/modules/logging

argparsing_remove_unknowns() {
    local short="$1"
    local long="$2"
    shift 2
    logging debug "options='$@'"
    # -q because we're not interested in unknown options
    getopt -q -o "$short" -l "$long" -- $@ | sed -E 's/[[:space:]]+--([[:space:]]+.*|$)//'
    local exit_code=$?
    # ignore exit code of 1 as that happens when some args are unknown and that's ok in this context
    (( exit_code > 1 )) && logging fail "getopt returned exit code $exit_code"
    return 0
}

# Parse command-line arguments
argparsing_parse_to_json() {
    logging debug "$FUNCNAME($@)..."

    # Load valid options into an associative array whose value is min_values, max_values
    declare -A valid_options

    local spec_file="${ARGPARSING_SPEC_FILE:-${BASH_SOURCE[1]}}" # default to calling script

    while IFS= read -r line; do
        # Only process lines that start with '##', have spaces, then a '-'
        [[ ! "$line" =~ ^##[[:space:]]+- ]] && continue

        # TODO: if the line doesn't have two spaces then treat the whole line as an option-spec
        # Ensure the line contains at least two spaces, separating the documentation
        if [[ "$line" =~ [[:space:]]{2,} ]]; then
            # Remove the leading `##` and extract only the option spec
            clean_line=$(sed -E 's/^##[[:space:]]+//; s/[[:space:]]{2,}.*//g' <<< "$line")

            # extract the option names and values, passing them out
            local count=0

            # Define regex patterns
            local regex_option="-[[:alnum:]_-]+"
            local regex_options="(^[[:space:]]*$regex_option([[:space:]]*,[[:space:]]*$regex_option)*)"
            # parse the options as a comma separated list
            if [[ ! "$clean_line" =~ $regex_options ]]; then
                logging fail "Failed to extract options from: '$clean_line'"
            fi

            local options_match=${BASH_REMATCH[1]} # match the comma separated list
            local values_match="${clean_line:${#options_match}}" # everything after
            # logging debug "options_match=$options_match"
            # logging debug "values_match=$values_match"

            # n n - v1 v2 v3
            # n 8 - v1 v2...
            # 2 5 - v1 v2 [v3 v4 v5]
            # 2 8 - v2 v2 [v1 v2...]
            # min is just the word count of everything up to [
            local min_args=$(echo "${values_match%%[*}" | wc -w)

            # max is the word count of all words (ignoring [ and ]) unless there is a ..., when it is infinite
            local max_args=-1
            if [[ ! $values_match == *"..."* ]]; then
                max_args=$(echo "${values_match//[\[\].]/}" | wc -w)
            fi

            IFS=',' read -ra options <<< "$options_match"

            for option in "${options[@]}"; do
                option="${option#"${option%%[![:space:]]*}"}"  # Trim leading spaces
                option="${option%"${option##*[![:space:]]}"}"  # Trim trailing spaces
                valid_options["$option"]="$min_args $max_args"
                logging debug "valid option -> $option $min_args $max_args"
            done

        else
            logging fail "Invalid format or missing documentation in line: '$line'"
        fi
    done < "$spec_file"

    # Process user-supplied arguments
    local json="{}"

    while [[ $# -gt 0 ]]; do
        local arg="$1"
        shift
        # TODO: handle arg=x,y,z
        local name="$arg"

        # Check if it's a valid option
        if [[ -v valid_options["$name"] ]]; then
            min_args=$(cut -d ' ' -f1 <<< "${valid_options[$name]}")
            max_args=$(cut -d ' ' -f2 <<< "${valid_options[$name]}")
            logging debug "name=$name; min_args=$min_args; max_args=$max_args"

            json=$(echo "$json" | jq -c ". + {\"$name\": []}")
            local arg_count=0
            # Collect arguments based on min/max requirements
            for ((i = 0; i < max_args || max_args == -1; i++)); do
                [[ $# -gt 0 && ! "$1" =~ ^- ]] || break
                ((arg_count++))
                logging debug "$arg_count: '$1'"
                # TODO: handle numerics?
                json=$(echo "$json" | jq -c ".[\"$name\"] += [\"$1\"]")
                shift
            done

            # Validate collected arguments against min/max constraints
            if (( $arg_count < min_args )); then
                logging fail "Option '$arg' requires at least $min_args arguments, but got ${#values[@]}."
            fi

        # else
        #     logging fail "Unknown option '$arg'"
        fi
    done

    echo "$json"
}
