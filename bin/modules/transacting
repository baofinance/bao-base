#!/bin/bash
set -e -o pipefail

if [[ -n "${GUARD_SOURCING_TRANSACTING:-}" ]]; then return; fi; GUARD_SOURCING_TRANSACTING=1
[[ -n "${LOADING:-}" ]] && echo "loading ${BASH_SOURCE[0]}..."

# shellcheck disable=SC1091
source "$(dirname "${BASH_SOURCE[0]}")/logging"
# shellcheck disable=SC1091
source "$(dirname "${BASH_SOURCE[0]}")/argparsing"

_transacting_get_contract_name() {
    local args="$1"
    local args_json
    local args_json=$(argsparsing_argparse '{"arguments":[

        ]}' "$args")
    argparsing_value 'contract_name' "$args_json"
}

_transacting_deploy_contract() {
    logging trace "${FUNCNAME[0]}($*)..."
    local purpose="$1"
    shift
    local args="$@"
    logging debug "purpose=$purpose."

    # TODO: have a way to build a spec from an array of args, or have argparsing_parse_args take that array
    local args_json=$(argparsing_argparse '{"arguments":[
        {"names": ["--contract-name"], "nargs": "?"},
        {"names": ["file_contract"], "nargs": 1},
        {"names": ["--constructor-args"], "nargs":"+"},
        {"names": ["--broadcast", "--no-broadcast"], "action": "store_boolean", "default": true},
        {"names": ["--verify", "--no-verify"], "action": "store_boolean"}]}' $args)
    local contract_name
    contract_name=$(argparsing_value "contract_namer" "$args_json")
    logging debug "contract_name=$contract_name."

    # get the contract to deploy
    local file_contract
    file_contract=$(argparsing_value "file_contract" "$args_json")
    logging debug "Deploying $file_contract."
    local contract_type="${file_contract#*:}"
    logging debug "contract_type=$contract_type."
    logging debug "contract_name=$contract_name."

    local contract_tag
    contract_tag=${contract_name}$([[ "$contract_name" == "" ]] && echo "$contract_type" || echo " ($contract_type)")${purpose:+ $purpose}

    logging info "Deploying the $contract_tag contract..."

    # TODO: allow the defaults to be owverridden
    local create_args="$file_contract"
    create_args+=" --rpc-url $default_rpc_url"
    create_args+=" --private-key $default_private_key"
    create_args+=" --etherscan-api-key $default_etherscan_api_key"
    local broadcast
    broadcast=$(argparsing_value "broadcast" "$args_json")
    [[ "$broadcast" != "false" ]] && create_args+=" --broadcast"
    local verify
    verify=$(argparsing_value "verify" "$args_json")
    verify=${verify:-$default_verify}
    # override the default value for verify (if set)
    [[ "$verify" != "false" ]] && create_args+=" --verify"
    # constructor args always goes last
    local constructor_args
    constructor_args=$(argparsing_value "constructor_args" "$args_json")
    [ -n "$constructor_args" ] && create_args+=" --constructor-args $constructor_args"


    logging info "$forge" create "$create_args"
    local response
    if ! response=$("$forge" create $create_args); then logging fatal "forge create failed for the $contract_tag contract."; fi
    logging trace "forge create->${response}."

    local deployer
    deployer=$(echo "$response" | awk '/Deployer:/ {print $2}')
    local address
    address=$(echo "$response" | awk '/Deployed to:/ {print $3}')
    local transaction
    transaction=$(echo "$response" | awk '/Transaction hash:/ {print $3}')

    if [ -z "$address" ]; then
        logging fail "Failed to deploy the $contract_tag contract."
        return 1
    fi

    logging info "Deployed the $contract_tag contact at $address"
    logging info "   by $deployer tx: $transaction"

    # return the result
    echo "$address"
}

transacting_deploy_contract() {
    local args="$@"
    _transacting_deploy_contract "non-upgradeable" "$args"
}

transacting_deploy_upgradeable_contract() {
    logging debug "deploy_upgreadable_contract($*)"
    local args="$@"

    # validate implementation

    # deploy implementation
    local implementation_address
    implementation_address=$(_transacting_deploy_contract "implementation" "$args")
    # save deployed data, for later validation

    # deploy proxy
    local proxy_address
    proxy_address=$(_transacting_deploy_contract 'UUPS proxy' \
        'lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol:ERC1967Proxy' \
        --constructor-args "$implementation_address" '0x')

    echo "$proxy_address"
}

function transacting_send () {
    local command="$1"
    shift
    cast send "$@"
}

function transacting_call () {
    local command="$1"
    shift
    cast call "$@"
}

function transacting_get_public_from_private() {
    local private_key="$1"
    cast wallet address --private-key "$private_key"
}


#####################################################################################
# private functions

_transacting_hide_sensitive_data_in_logs() {
    for args_json in "$@"; do
        for field in "private_key" "etherscan_api_key"; do
            logging trace "hiding $field in logs"
            local value
            value=$(argparsing_value $field "$args_json")
            if [ -n "$value" ]; then
                local replacement="***${field}***"
                # add a user friendly replacement, e.g. public key for a private key
                if [[ "$value" =~ ^0x[0-9a-fA-F]{64}$ ]]; then
                    logging trace "found private key"
                    local public_key
                    public_key=$(transacting_get_public_from_private "$value")
                    [ -n "$public_key" ] && replacement="***${field} [public key:$public_key]***"
                fi
                logging_hide "$value" "$replacement"
            fi
        done
    done
}

_transacting_lookup_env() {
    logging trace "${FUNCNAME[0]}($*)..."
    local env_name="$1"
    local field_name="$2"
    # look up the environment
    local value=""

    # Check if the variable exists before trying to access it
    if declare -p "$env_name" &>/dev/null; then
        eval "value=\${$env_name}"
    fi

    logging debug "   environment $env_name=$value"
    if [[ -n "$value" ]]; then
        logging info "$field_name taken from the environment variable $env_name"
    else
        # look up the .env file if it exists
        if [[ -f .env ]]; then
            # Use a subshell to source .env without polluting the parent environment
            value=$(
                # shellcheck disable=SC1091 # file exists check above
                source .env
                if declare -p "$env_name" &>/dev/null; then
                    eval "echo \${$env_name}"
                else
                    echo ""
                fi
            )

            logging debug "   .env $env_name=$value"
            if [[ -n "$value" ]]; then
                logging info "$field_name taken from the .env file variable $env_name"
            fi
        fi
    fi
    logging trace "${FUNCNAME[0]}->$value."
    echo "$value"
}

# update the _transacting_config global from env, if not already there
_transacting_default_from_env() {
    logging trace "${FUNCNAME[0]}($*)..."
    local origin="$1" # this is the longest arg in the list (preferring long form)
    local env_name="$2" # the environment variable name
    local existing_json="$3" # the existing args_json to update
    local field_name
    # make the field name out of the origin but de-hyphenating it
    field_name=$(echo "$origin" | sed -E 's/^-+//; s/-/_/g') || exit $?

    if ! argparsing_has "$field_name" "$existing_json"; then
        local value
        value=$(_transacting_lookup_env "$env_name" "$field_name")
        if [ -n "$value" ]; then
            existing_json=$(argparsing_add "$field_name" "$existing_json" "$value" "$origin")
        fi
    fi
    echo "$existing_json"
}

_transacting_arg_spec='{"arguments":[
{"names":["--rpc-url"], "default": "local"},
{"names":["--private-key"]},
{"names":["--etherscan-api-key"]},
{"names": ["--verify", "--no-verify"], "action": "store_boolean"}
]}'

forge=$(command -v forge)
logging info "using forge at $forge."

args_json=$(argparsing_argparse "$_transacting_arg_spec" "$@")

# read environment variables or .env file, in that order of precedence
args_json=$(_transacting_default_from_env "--private-key" "PRIVATE_KEY" "$args_json")
args_json=$(_transacting_default_from_env "--etherscan-api-key" "ETHERSCAN_API_KEY" "$args_json")
_transacting_hide_sensitive_data_in_logs "$args_json"

# set the global variables to be used in subsequent functions
default_rpc_url=$(argparsing_value "rpc_url" "$args_json")
default_private_key=$(argparsing_value "private_key" "$args_json")
default_etherscan_api_key=$(argparsing_value "etherscan_api_key" "$args_json")
# get the default verify - if not specified, then use the default for the rpc_url
default_verify=$(argparsing_value "verify" "$args_json")
if [[ "$default_verify" == "" ]]; then
    # nothing specified, default depending on the network
    if [[ "$default_rpc_url" == "local" ]]; then
        default_verify="false"
    else
        default_verify="true"
    fi
fi

# tell the user what the defaults are
logging info "transaction defaults:$(argparsing_args $args_json)"