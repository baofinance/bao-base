#!/bin/bash
set -e -o pipefail

if [[ -n "${GUARD_SOURCING_TRANSACTING:-}" ]]; then return; fi; GUARD_SOURCING_TRANSACTING=1
[[ -n "${LOADING:-}" ]] && echo "loading ${BASH_SOURCE[0]}..."

# shellcheck disable=SC1091
source "$(dirname "${BASH_SOURCE[0]}")/logging"
# shellcheck disable=SC1091
source "$(dirname "${BASH_SOURCE[0]}")/argparsing"

_transacting_network_args_json=""
_transacting_network_arg_spec=('["--rpc-url"], "default": "local"')

_transacting_tx_args_json=""
_transacting_tx_arg_spec=('["--private-key"]')

# todo: make no-broadcast and no-verify actually result in the argument being removed
_transacting_deploy_args_json=""
_transacting_deploy_arg_spec=(\
    '["file_contract"], "nargs": "?"' \
    '["--constructor-args"], "nargs":"+"' \
    '["--broadcast", "--no-broadcast"], "action": "store_boolean", "default": true' \
    '["--etherscan-api-key"]' \
    '["--verify", "--no-verify"], "action": "store_boolean"')
# TODO: remove these args and pass them as parameters to _deploy_contract
_transacting_deploy_extra_args_json=""
_transacting_deploy_extra_arg_spec=( \
    '["--contract-name"]' \
    '["--purpose"]')

_make_spec() {
    local combined_output
    combined_output=$(for arr_name in "$@"; do
        eval 'printf "%s\n" "${'"${arr_name}"'[@]}"'
    done) || exit $?
    local result
    result=$(echo "$combined_output" | jq -Rsc '
        split("\n")
        | map(select(length > 0))
        | map("{\"names\":" + . + "}")
        | map(fromjson)
        | {arguments: .}
    ') || exit $?
    echo "$result"
}

_transacting_all_spec=$(_make_spec _transacting_network_arg_spec _transacting_tx_arg_spec _transacting_deploy_arg_spec _transacting_deploy_extra_arg_spec)
_transacting_network_spec=$(_make_spec _transacting_network_arg_spec)
_transacting_tx_spec=$(_make_spec _transacting_tx_arg_spec)
_transacting_deploy_spec=$(_make_spec _transacting_deploy_arg_spec)
_transacting_deploy_extra_spec=$(_make_spec _transacting_deploy_extra_arg_spec)

forge=$(command -v forge)
logging info "using forge at $forge."


transacting_config_value() {
    local field="$1"
    argparsing_value "$field" "$_transacting_network_args_json" \
    || argparsing_value "$field" "$_transacting_tx_args_json" \
    || argparsing_value "$field" "$_transacting_deploy_args_json" \
    || argparsing_value "$field" "$_transacting_deploy_extra_args_json"
}

transacting_config() {
    logging trace "${FUNCNAME[0]}($*)..."
    local args_json
    args_json=$(argparsing_argparse "$_transacting_all_spec" "$@")
    args_json=$(argparsing_remove_unknown "$args_json")
    _transacting_hide_sensitive_data_in_logs "$args_json"
    logging debug "args_json=$args_json."

    # extract the default for each level of interaction
    _transacting_network_args_json=$(argparsing_keep "$_transacting_network_spec" "$args_json")
    logging trace "_transacting_network_args_json=$_transacting_network_args_json."
    _transacting_tx_args_json=$(argparsing_keep "$_transacting_tx_spec" "$args_json")
    logging trace "_transacting_tx_args_json=$_transacting_tx_args_json."
    _transacting_deploy_args_json=$(argparsing_keep "$_transacting_deploy_spec" "$args_json")
    logging trace "_transacting_deploy_args_json=$_transacting_deploy_args_json."
    _transacting_deploy_extra_args_json=$(argparsing_keep "$_transacting_deploy_extra_spec" "$args_json")
    logging trace "_transacting_deploy_extra_args_json=$_transacting_deploy_extra_args_json."

    # read environment variables or .env file, in that order of precedence
    _transacting_tx_args_json=$(_transacting_default_from_env "--private-key" "PRIVATE_KEY" "$_transacting_tx_args_json")
    _transacting_deploy_args_json=$(_transacting_default_from_env "--etherscan-api-key" "ETHERSCAN_API_KEY" "$_transacting_deploy_args_json")
    _transacting_hide_sensitive_data_in_logs "$_transacting_tx_args_json" "$_transacting_deploy_args_json"

    # tell the user what the defaults are
    local defaults
    defaults=$(argparsing_args "$_transacting_network_args_json") || exit $?
    defaults+=$(argparsing_args "$_transacting_tx_args_json") || exit $?
    defaults+=$(argparsing_args "$_transacting_deploy_args_json")  || exit $?
    defaults+=$(argparsing_args "$_transacting_deploy_extra_args_json") || exit $?
    logging info "transaction defaults:$defaults"
}


_transacting_deploy_contract() {
    logging trace "${FUNCNAME[0]}($*)..."
    local args_json="$1"

    # merge the given args with the defaults, given args override
    args_json=$(argparsing_merge "$_transacting_network_args_json" "$_transacting_tx_args_json" "$_transacting_deploy_args_json" "$_transacting_deploy_extra_args_json" "$args_json")
    logging trace "args_json=$args_json."

    # get the contract to deploy
    local file_contract
    file_contract=$(argparsing_value "file_contract" "$args_json")
    logging debug "deploying $file_contract."

    local contract_type="${file_contract#*:}"
    logging debug "contract_type=$contract_type."
    local contract_name
    contract_name=$(argparsing_value "contract_name" "$args_json")
    logging debug "contract_name=$contract_name."

    local purpose
    purpose=$(argparsing_value "purpose" "$args_json")

    local contract_tag
    contract_tag=${contract_name}$([[ "$contract_name" == "" ]] && echo "$contract_type" || echo " ($contract_type)")${purpose:+ $purpose}

    logging info "deploying the $contract_tag contract..."
    args_json=$(argparsing_remove "purpose" "$args_json")
    args_json=$(argparsing_remove "contract_name" "$args_json")
    args=$(argparsing_args "$args_json" known)
    logging debug "args=$args."

    # todo: remove the args_array?
    local args_array
    eval "args_array=($args)"
    logging trace "$forge" create "${args_array[@]}"
    local response
    if ! response=$("$forge" create "${args_array[@]}"); then logging fatal "forge create failed for the $contract_tag contract."; fi
    logging trace "forge create->${response}."

    local deployer
    deployer=$(echo "$response" | awk '/Deployer:/ {print $2}')
    local address
    address=$(echo "$response" | awk '/Deployed to:/ {print $3}')
    local transaction
    transaction=$(echo "$response" | awk '/Transaction hash:/ {print $3}')

    if [ -z "$address" ]; then
        logging fail "Failed to deploy the $contract_tag contract."
        return 1
    fi

    logging info "Deployed the $contract_tag contact at $address"
    logging info "   by $deployer tx: $transaction"

    # return the result
    echo "$address"
}

transacting_deploy_contract() {
    logging trace "${FUNCNAME[0]}($*)..."
    local args_json
    args_json=$(argparsing_argparse "$_transacting_all_spec" "$@") || exit $?
    _transacting_hide_sensitive_data_in_logs "$args_json"
    logging debug "args_json=$args_json."
    _transacting_deploy_contract "$args_json"
}

transacting_deploy_upgradeable_contract() {
    logging debug "deploy_upgreadable_contract($*)"
    local args_json
    args_json=$(argparsing_argparse "$_transacting_deploy_spec" "$@")
    _transacting_hide_sensitive_data_in_logs "$args_json"
    local file_contract
    file_contract=$(argparsing_value "file_contract" "$args_json")
    local file="${file_contract%%:*}"
    logging debug "file=$file."

    # validate implementation

    # deploy implementation
    local implementation_args
    implementation_args=$(argparsing_add purpose "$args_json" implementation)
    logging debug "implementation_args=$implementation_args."
    local implementation_address
    implementation_address=$(_transacting_deploy_contract "$implementation_args") || logging FATAL "failed to deploy $file_contract implementation contract."
    # save deployed data, for later validation

    # deploy proxy
    local proxy_args
    proxy_args=$(argparsing_argparse "$_transacting_all_spec" \
        --purpose 'UUPS proxy' \
        'lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol:ERC1967Proxy' \
        --constructor-args "$implementation_address" '0x')

    local proxy_address
    proxy_address=$(_transacting_deploy_contract "$proxy_args") || logging FATAL "failed to deploy $file_contract proxy contract."

    echo "$proxy_address"
}

function transacting_send () {
    local command="$1"
    shift
    cast send "$@"
}

function transacting_call () {
    local command="$1"
    shift
    cast call "$@"
}

function get_public_from_private() {
    local private_key="$1"
    cast wallet address --private-key "$private_key"
}


#####################################################################################
# private functions

_transacting_hide_sensitive_data_in_logs() {
    for args_json in "$@"; do
        for field in "private_key" "etherscan_api_key"; do
            logging trace "hiding $field in logs"
            local value
            value=$(argparsing_value $field "$args_json")
            if [ -n "$value" ]; then
                local replacement="***${field}***"
                # add a user friendly replacement, e.g. public key for a private key
                if [[ "$value" =~ ^0x[0-9a-fA-F]{64}$ ]]; then
                    logging trace "found private key"
                    local public_key
                    public_key=$(get_public_from_private "$value")
                    [ -n "$public_key" ] && replacement="***${field} [public key:$public_key]***"
                fi
                logging_hide "$value" "$replacement"
            fi
        done
    done
}

_transacting_lookup_env() {
    logging trace "${FUNCNAME[0]}($*)..."
    local env_name="$1"
    local field_name="$2"
    # look up the environment
    local value=""

    # Check if the variable exists before trying to access it
    if declare -p "$env_name" &>/dev/null; then
        eval "value=\${$env_name}"
    fi

    logging debug "   environment $env_name=$value"
    if [[ -n "$value" ]]; then
        logging info "$field_name taken from the environment variable $env_name"
    else
        # look up the .env file if it exists
        if [[ -f .env ]]; then
            # Use a subshell to source .env without polluting the parent environment
            value=$(
                # shellcheck disable=SC1091 # file exists check above
                source .env
                if declare -p "$env_name" &>/dev/null; then
                    eval "echo \${$env_name}"
                else
                    echo ""
                fi
            )

            logging debug "   .env $env_name=$value"
            if [[ -n "$value" ]]; then
                logging info "$field_name taken from the .env file variable $env_name"
            fi
        fi
    fi
    logging trace "${FUNCNAME[0]}->$value."
    echo "$value"
}

# update the _transacting_config global from env, if not already there
_transacting_default_from_env() {
    logging trace "${FUNCNAME[0]}($*)..."
    local origin="$1" # this is the longest arg in the list (preferring long form)
    local env_name="$2" # the environment variable name
    local existing_json="$3" # the existing args_json to update
    local field_name
    # make the field name out of the origin but de-hyphenating it
    field_name=$(echo "$origin" | sed -E 's/^-+//; s/-/_/g') || exit $?

    if ! argparsing_has "$field_name" "$existing_json"; then
        local value
        value=$(_transacting_lookup_env "$env_name" "$field_name")
        if [ -n "$value" ]; then
            existing_json=$(argparsing_add "$field_name" "$existing_json" "$value" "$origin")
        fi
    fi
    echo "$existing_json"
}
