#!/usr/bin/env bash
set -euo pipefail

# Report current shell and bash version/path (works in Bash 3.2+)
if [ -n "${BASH_VERSION:-}" ]; then
  # Running under bash
  echo "Bash in use: ${BASH_VERSION} (path: ${BASH:-unknown})" >&2
  # Optional: check for >= 5.2
  major=${BASH_VERSINFO[0]:-0}
  minor=${BASH_VERSINFO[1]:-0}
  if { [ "$major" -gt 5 ] || { [ "$major" -eq 5 ] && [ "$minor" -ge 2 ]; }; }; then
    echo "Bash meets minimum 5.2 requirement" >&2
  else
    echo "Bash is below 5.2; PATH/runner may point to older bash" >&2
  fi
else
  # Not running under bash (e.g., sh); show process and default bash
  shell_name=$(ps -p $$ -o comm= 2>/dev/null || echo "${SHELL:-unknown}")
  echo "Not running under bash (current shell: ${shell_name})" >&2
  echo "Default bash in PATH: $(command -v bash 2>/dev/null || echo 'not found')" >&2
  echo "Default bash version: $(bash --version 2>/dev/null | head -n1 || echo 'unknown')" >&2
fi

# only check the src files
FOUNDRY_OUT="out/_validate" # there's no command option to set this
BUILD_INFO_DIR="$FOUNDRY_OUT/build-info"
mkdir -p "${BUILD_INFO_DIR}"
# build again with build-info this time, so we force
forge build --out ${FOUNDRY_OUT} --build-info --build-info-path "${BUILD_INFO_DIR}" --extra-output storageLayout --skip "**/*.vy" --skip "**/*.t.sol" --skip "**/*.s.sol" --force src
echo
echo "running OpenZeppelin upgrades-core validate..."
echo "-------------------------------------------"
echo
npx @openzeppelin/upgrades-core validate "${BUILD_INFO_DIR}" || error "OpenZeppelin upgrades-core validate failed"

# check for root storage access
echo
echo "checking namespace-only storage policy..."
echo "--------------------------------------"
echo
contracts=$(npx @openzeppelin/upgrades-core validate "${BUILD_INFO_DIR}" | grep -o -E '[^[:space:]]+.sol:[A-Za-z_][A-Za-z0-9_]*')

# Allowed storage slot: OpenZeppelin Initializable (ERC-7201)
# ALLOWED_OZ_INIT_SLOT=$(cast index-erc7201 openzeppelin.storage.Initializable)
ALLOWED_OZ_INIT_SLOT="f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00"

failed=0
for contract in ${contracts}; do
    this_failed=0
    # skip libraries
    if [[ "$contract" == "lib/"* ]]; then
        continue
    fi
    # special case for Stem
    if [[ "$contract" == *"Stem"*".sol:"*"Stem"* ]]; then
        continue
    fi

    ################################################################
    # check for storage slots not in a namespace (i.e. root slots)
    ################################################################
    root_slots=$(forge inspect --out ${FOUNDRY_OUT} --json $contract storage-layout | jq '.storage | length')
    if [[ "${root_slots}" != "" && "${root_slots}" -gt 0 ]]; then
        echo "ERROR: Root slots for ${contract}: ${root_slots}\n$(forge inspect $contract storage-layout)"
        this_failed=1
    fi

    ################################################################
    # check for constructor initialised storage
    # - Must SSTORE exactly once, to OZ Initializable slot
    # - No second SSTORE allowed (any other constructor write is disallowed)
    ################################################################

    init=$(forge inspect --out ${FOUNDRY_OUT} "$contract" bytecode | tr -d '\n')
    runtime=$(forge inspect --out ${FOUNDRY_OUT} "$contract" deployedBytecode | tr -d '\n')

    # Mandatory: contracts must have constructor code and call _disableInitializers()
    if [ "$init" = "0x" ] || [ "$runtime" = "0x" ]; then
        echo "ERROR: Constructor does not call _disableInitializers(); (no creation/runtime bytecode) in $contract"
        this_failed=1
    else
        # Isolate constructor (init) by trimming runtime tail
        # pos=$(echo -n "$init" | grep -aob -- "${runtime#0x}" | tail -n1 | cut -d: -f1 || true) # OOM on macos
        pos=$(node -e "const a=(process.argv[1]||'').toLowerCase(); const b=(process.argv[2]||'').replace(/^0x/,'').toLowerCase(); const i=a.lastIndexOf(b); if(i>=0) process.stdout.write(String(i));" "$init" "$runtime" 2>/dev/null || true)
        if [ -n "$pos" ]; then
            init="${init:0:$pos}"
        else
            echo "WARNING: Couldn't locate runtime inside creation for $contract; scanning full creation code"
        fi

        # Count SSTOREs in init
        disasm=$(cast disassemble "$init")
        sstore_count=$(echo "$disasm" | grep -ci '\bSSTORE\b' || true)
        sload_count=$(echo "$disasm" | grep -ci '\bSLOAD\b' || true)

        # Require exactly one SSTORE (the _disableInitializers write)
        if [ "${sstore_count:-0}" -eq 0 ]; then
            echo "ERROR: Constructor does not call _disableInitializers() (no SSTORE) in $contract"
            this_failed=1
        elif [ "${sstore_count:-0}" -gt 1 ]; then
            echo "ERROR: Constructor performs multiple SSTOREs in $contract (only Initializable write allowed)"
            this_failed=1
        fi

        # echo $init
        # exit 0
        # Require the Initializable ERC-7201 slot bytes to appear in constructor bytecode
        if ! echo "$init" | grep -q "${ALLOWED_OZ_INIT_SLOT}"; then
            echo "ERROR: Constructor does not reference Initializable slot (erc7201) in $contract"
            this_failed=1
        fi

        # Enforce: exactly one SSTORE, and it must target the Initializable slot
        # if ! echo "$disasm" | awk -v slot="${ALLOWED_OZ_INIT_SLOT}" '
        #     BEGIN { pushline=0; total=0; toslot=0; bad=0; window=256 }
        #     /PUSH[0-9]+/ { if (index($0, slot) > 0) { pushline=NR } next }
        #     /SSTORE\b/   {
        #         total++
        #         if (pushline > 0 && (NR - pushline) <= window) { toslot++ } else { bad=1 }
        #         next
        #     }
        #     END { exit(bad || total != 1 || toslot != 1 ? 1 : 0) }
        # '; then
        #     warn "Constructor does not perform exactly one SSTORE to Initializable in $contract"
        #     this_failed=1
        # fi
    fi

    if [[ $this_failed -ne 0 ]]; then
        failed=1
        echo " âœ˜  ${contract}"
    else
        echo " âœ”  ${contract}"
    fi
    echo ""
done
if [[ $failed -ne 0 ]]; then
    echo "ERROR: some contracts have root storage or constructor-initialized storage"
    return 1
fi
echo "SUCCESS: (no contracts have root storage or constructor-initialized storage)"
