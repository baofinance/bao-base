#!/usr/bin/env bash
set -euo pipefail

# assumed environment variables - also keeps shellcheck happy
BAO_BASE_BIN_DIR=$BAO_BASE_BIN_DIR
BAO_BASE_DIR=$BAO_BASE_DIR
BAO_BASE_OS=$BAO_BASE_OS
BAO_BASE_VERBOSITY=$BAO_BASE_VERBOSITY

source "$BAO_BASE_BIN_DIR/run/platform-utils.sh"

# Set the path to the script
SCRIPT="$1"
shift
debug "Script to run: $SCRIPT"
debug "Arguments: $*"
debug "Verbosity level: $BAO_BASE_VERBOSITY"

# Set up directories: if "script" is a directory, use
if [ ! -d "$BAO_BASE_BIN_DIR/$SCRIPT" ]; then
  DEPENDENCIES_DIR="$BAO_BASE_BIN_DIR"
else
  DEPENDENCIES_DIR="$BAO_BASE_BIN_DIR/$SCRIPT"
fi
debug "Dependencies directory: $DEPENDENCIES_DIR"

# don't touch .profile or .bashrc
export UV_UNMANAGED_INSTALL=1

# Local directories for tools and environments
UV_DIR="$BAO_BASE_TOOLS_DIR/uv"
VENV_DIR="$DEPENDENCIES_DIR/.venv"
export UV_PYTHON_BIN_DIR="$BAO_BASE_TOOLS_DIR/python/bin"

export UV_CACHE_DIR="$BAO_BASE_TOOLS_DIR/uv-cache"

# Define uv and virtual environment paths based on OS
VENV_PYTHON_PATH="$VENV_DIR/$(python_exe_in_env)"
VENV_ACTIVATE_PATH="$VENV_DIR/$(activate_script_in_env)"
UV_BIN="$UV_DIR/$(uv_exe_name)"

# check if everything is in place (if not we make it so later)
debug "VENV_PYTHON_PATH:" $(ls -la "$VENV_PYTHON_PATH" || true)
debug "VENV_ACTIVATE_PATH:" $(ls -la "$VENV_ACTIVATE_PATH" || true)
debug "UV_BIN:" $(ls -la "$UV_BIN" || true)

# get verbosity flags for UV based on BAO_BASE_VERBOSITY
if [[ $BAO_BASE_VERBOSITY -lt 0 ]]; then
  UV_FLAGS="-qq --no-progress" # Quiet mode
else
  case "$BAO_BASE_VERBOSITY" in
    0) UV_FLAGS="-qq" ;;
    1) UV_FLAGS="-q" ;;
    2) UV_FLAGS="" ;;
    *) UV_FLAGS="--verbose" ;;
  esac
fi
debug "Using UV flags: $UV_FLAGS"

# Install uv locally
if [[ ! -x "$UV_BIN" ]]; then
  debug "uv not found at $UV_BIN, installing to $UV_DIR..."

  # Create temp directory safely across platforms
  temp_script=$(create_temp_file "uvinstall")
  temp_install_dir=$(create_temp_dir "uvinstalldir")

  curl -fsSL https://astral.sh/uv/install.sh -o "$temp_script" || {
    rm -rf "$temp_install_dir" "$temp_script"
    error "Failed to download uv install script"
    exit 1
  }
  make_executable "$temp_script"

  # Install uv to a temporary directory - redirect output on Windows
  debug "Installing uv to temp directory: $temp_install_dir"
  capture_output "CARGO_HOME='$temp_install_dir/cargo' RUSTUP_HOME='$temp_install_dir/rustup' UV_INSTALL_DIR='$UV_DIR' NO_MODIFY_PATH=1 '$temp_script'" true || {
    rm -rf "$temp_install_dir" "$temp_script"
    error "Failed to run uv install script"
    exit 1
  }

  rm -rf "$temp_install_dir" "$temp_script"
  debug "uv installed successfully to: $UV_BIN"
fi
debug "Using uv at: $UV_BIN:" $($UV_BIN --version)

# Check for pyproject.toml
PYPROJECT_TOML="$DEPENDENCIES_DIR/pyproject.toml"
if [[ ! -f "$PYPROJECT_TOML" ]]; then
  error "No pyproject.toml found at $PYPROJECT_TOML"
  exit 1
fi
debug "Found pyproject.toml file at $PYPROJECT_TOML"

# Generate hash for pyproject.toml
PYPROJECT_TOML_HASH=$(calculate_hash "$PYPROJECT_TOML")
debug "Generated hash for pyproject.toml: $PYPROJECT_TOML_HASH"

# Check for existing .python-version and uv.lock
PYTHON_VERSION_LOCK="$DEPENDENCIES_DIR/.python-version"
UV_LOCK="$DEPENDENCIES_DIR/uv.lock"

# Function to check if files exist and have valid hashes
validate_lock() {
  local lock_file="$1"

  # Check if both files exist
  if [[ ! -f "$lock_file" ]]; then
    info 0 "$lock_file does not exist."
    return 1
  fi

  local lock_hash
  lock_hash=$(grep -E "^# HASH:[a-f0-9]{64}$" "$lock_file" | head -1 | cut -d':' -f2)
  if [[ -z "$lock_hash" ]]; then
    info 0 "No hash found in $lock_file."
    return 1
  fi

  # Check if hashes match
  if [[ "$lock_hash" != "$PYPROJECT_TOML_HASH" ]]; then
    info 0 "$lock_file out of date (hash mismatched)."
    debug "Hash mismatch:"
    debug "$PYPROJECT_TOML: $PYPROJECT_TOML_HASH"
    debug "Lock file: $lock_hash"
    return 1
  fi

  debug "Lock file $lock_file exist with matching hash"
  return 0
}

# Check if we have a virtual environment or the python version lock file is valid
PYTHON_VERSION_LOCKED=$(validate_lock "$PYTHON_VERSION_LOCK" && echo true || echo false)
PYTHON_ENV_EXISTS=$([[ -f "$VENV_ACTIVATE_PATH" ]] && echo true || echo false)

# if the python version is not locked OR the virtual environment does not exist, we need to create a virtual environment with the right version of python
if [[ "$PYTHON_VERSION_LOCKED" != "true" || "$PYTHON_ENV_EXISTS" != "true" ]]; then
  debug "Need to create a venv"
  if [[ "$PYTHON_VERSION_LOCKED" == "true" ]]; then
    # we have the version and uv will read it from the .python-version file
    debug "using the python version from .python-version file"
    PYTHON_CONSTRAINT=$(tail -n 1 "$PYTHON_VERSION_LOCK")
    PYTHON_CONSTRAINT_ARG=""
    PYTHON_CONSTRAINT_SOURCE=".python-version"
  else
    # Extract requires-python value from pyproject.toml using a simple grep pattern
    # This works for basic cases, but might need improvement for complex formatting
    PYTHON_CONSTRAINT=$(grep -E 'requires-python\s*=\s*"[^"]+"' "$PYPROJECT_TOML" | sed 's/.*"\(.*\)".*/\1/')
    if [[ -z "$PYTHON_CONSTRAINT" ]]; then
      debug "No requires-python constraint found in $PYPROJECT_TOML, using '3' (i.e. the latest version)"
      PYTHON_CONSTRAINT="3"
      PYTHON_CONSTRAINT_SOURCE="default"
    else
      PYTHON_CONSTRAINT_SOURCE="pyproject.toml"
    fi
    PYTHON_CONSTRAINT_ARG="--python $PYTHON_CONSTRAINT"
  fi
  debug "Using Python constraint: $PYTHON_CONSTRAINT"

  # Create virtual environment with specified Python version using uv env (uses the .python-version file, if it exists and --python is not specified)
  debug "Creating environment with Python constraint: $PYTHON_CONSTRAINT"
  # also stop this from updating .profile & .bashrc
  UV_PYTHON_INSTALL_DIR="$BAO_BASE_TOOLS_DIR/python/install" "$UV_BIN" $UV_FLAGS venv --managed-python $PYTHON_CONSTRAINT_ARG "$VENV_DIR" || {
    error "Failed to create virtual environment with Python constraint $PYTHON_CONSTRAINT"
    exit 1
  }

  # Get the actual Python version that was installed and use it to create .python-version
  [[ -f "$VENV_PYTHON_PATH" ]] || error "Failed to find Python at $VENV_PYTHON_PATH in virtual environment
$BAO_BASE_OS virtual environment directory structure:
$(ls -la "$VENV_DIR" || true)
$(ls -la "$VENV_DIR/Scripts" 2>/dev/null || true)
$(ls -la "$VENV_DIR/bin" 2>/dev/null || true)"

  # Extract the actual Python version from the venv
  debug "Checking Python version in virtual environment"
  ACTUAL_PYTHON_VERSION=$("$VENV_PYTHON_PATH" -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")

  # Create .python-version file with the actual version and hash
  {
    echo "# This file was auto-generated by run-python using a constraint from $PYTHON_CONSTRAINT_SOURCE: $PYTHON_CONSTRAINT"
    echo "# HASH:$PYPROJECT_TOML_HASH"
    echo "$ACTUAL_PYTHON_VERSION"
  } >"$PYTHON_VERSION_LOCK"
  debug "Created .python-version file with version $ACTUAL_PYTHON_VERSION and hash"
fi

if ! validate_lock "$UV_LOCK"; then
  debug "Generating $UV_LOCK from $PYPROJECT_TOML"
  rm -f "$UV_LOCK"
  # Use capture_output to prevent output from appearing in files (Windows support)
  capture_output "'$UV_BIN' $UV_FLAGS lock --directory '$DEPENDENCIES_DIR'" true || {
    error "Failed to lock dependencies"
    exit 1
  }

  # Add our hash to the uv.lock file
  echo "# HASH:$PYPROJECT_TOML_HASH" >>"$UV_LOCK"
  debug "Generated $UV_LOCK with hash"
fi

# # Verify the Python interpreter in the venv
# if [[ ! -f "$VENV_PYTHON_PATH" ]]; then
#   error "Python executable not found at $VENV_PYTHON_PATH in virtual environment"
#   if [[ "$BAO_BASE_OS" == "windows" ]]; then
#     debug "Windows virtual environment directory structure:"
#     ls -la "$VENV_DIR" || true
#     ls -la "$VENV_DIR/Scripts" 2>/dev/null || true
#   else
#     debug "Virtual environment directory structure:"
#     ls -la "$VENV_DIR" || true
#     ls -la "$VENV_DIR/bin" 2>/dev/null || true
#   fi
#   exit 1
# fi

# # Make Python executable is executable
# make_executable "$VENV_PYTHON_PATH" || {
#   error "Failed to make Python executable: $VENV_PYTHON_PATH"
#   exit 1
# }

# # Print Python version information based on verbosity level
# PYTHON_VERSION=$("$VENV_PYTHON_PATH" -c "import sys; print(f'Using {sys.implementation.name} {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}')")
# info 1 "$PYTHON_VERSION"
# info 2 "Activate with: source $VENV_ACTIVATE_PATH"

# Install dependencies using our local uv
debug "Installing dependencies from generated uv.lock"

# Activate the virtual environment - handle Windows differently
if [[ "$BAO_BASE_OS" == "windows" ]]; then
  # On Windows, we directly call the venv's python since activate can be tricky in bash
  debug "Running on Windows - directly using Python from venv without activation"
  PYTHON_CMD="$VENV_PYTHON_PATH"

  # Install dependencies directly with UV
  debug "Installing dependencies using UV directly on Windows"
  capture_output "'$UV_BIN' $UV_FLAGS sync --directory '$DEPENDENCIES_DIR'" true || {
    error "Failed to sync dependencies from uv.lock"
    exit 1
  }
else
  # On Unix systems, use the traditional activation approach
  source "$VENV_ACTIVATE_PATH" || {
    error "Failed to activate virtual environment at $VENV_ACTIVATE_PATH"
    exit 1
  }

  "$UV_BIN" $UV_FLAGS sync --directory "$DEPENDENCIES_DIR" || {
    error "Failed to sync dependencies from uv.lock"
    deactivate 2>/dev/null || true
    exit 1
  }
  PYTHON_CMD="python"
fi

debug "Dependencies installed successfully"

# Run the target Python script or command
# Handle absolute paths and paths that already have .py extension
if [[ "$SCRIPT" == *.py ]]; then
  # Script already has a .py extension - use as-is
  if [[ "$SCRIPT" == /* ]]; then
    # Absolute path
    SCRIPT_PY="$SCRIPT"
  else
    # Relative path with .py extension
    SCRIPT_PY="$DEPENDENCIES_DIR/$SCRIPT"
  fi
  debug "Using script with existing .py extension: $SCRIPT_PY"
elif [[ "$SCRIPT" == /* ]]; then
  # Absolute path without .py extension
  SCRIPT_PY="${SCRIPT}.py"
  debug "Using absolute path with added .py extension: $SCRIPT_PY"
else
  # Relative path without .py extension
  SCRIPT_PY="$DEPENDENCIES_DIR/$SCRIPT.py"
  debug "Using relative path with added .py extension: $SCRIPT_PY"
fi

export PYTHONPATH="$BAO_BASE_DIR:$BAO_BASE_BIN_DIR"

if [[ -f "$SCRIPT_PY" ]]; then
  debug "Running Python script: $SCRIPT_PY"
  if [[ "$BAO_BASE_OS" == "windows" ]]; then
    "$VENV_PYTHON_PATH" "$SCRIPT_PY" "$@"
  else
    $PYTHON_CMD "$SCRIPT_PY" "$@"
  fi
else
  # Check if the script exists as a system command
  if command -v "$SCRIPT" &>/dev/null; then
    debug "Running Python command: $SCRIPT"
    # Run the command
    "$SCRIPT" "$@"
  else
    error "Python script '$SCRIPT_PY' not found and command '$SCRIPT' not found in PATH"
    # Additional error information for debugging
    debug "Script: $SCRIPT"
    debug "Script path attempted: $SCRIPT_PY"
    debug "Dependencies directory: $DEPENDENCIES_DIR"
    exit 1
  fi
fi

# Deactivate the virtual environment (not needed on Windows when we didn't activate)
if [[ "$BAO_BASE_OS" != "windows" ]]; then
  deactivate 2>/dev/null || true
fi
