#!/usr/bin/env bash

# logging
# logging takes three forms
# 1. error messages - these are always printed. The process should terminate.
# 2. info messages - these are printed according to a verbosity level.
# 3. debug messages - these are printed if and only if the script name is in the DEBUG list.

first_free_fd() {
  local current_fds=$(lsof -p $$ | awk '$4 ~ /^([0-9]+)[urw]*$/ {print +$4}' | sort -n)
  prev=2
  for fd in $(echo "$current_fds"); do
    if [ $((fd)) -gt $((prev + 1)) ]; then
      echo $((prev + 1))
      return
    fi
    prev=$fd
  done
  echo $((prev + 1))
}

# set the file descriptor for logging this must be 2 or it interferes with anvil (go figure)
export LOGGING_FILE_DESCRIPTOR=${LOGGING_FILE_DESCRIPTOR:-2}
# redirect this to stdout, so it's stdout but functions can log but not affect their output
# who said bash was a good idea?
# exec 8> >(stdbuf -o0 cat)
case "$LOGGING_FILE_DESCRIPTOR" in
3)
  exec 3>&1
  ;;
4)
  exec 4>&1
  ;;
5)
  exec 5>&1
  ;;
6)
  exec 6>&1
  ;;
7)
  exec 7>&1
  ;;
8)
  exec 8>&1
  ;;
9)
  exec 9>&1
  ;;
esac

debug_opts() {
  # extract options from DEBUG variable
  local debug_options=""
  local IFS=','
  for item in ${DEBUG:-}; do
    # If item starts with dash, add it to debug_options
    if [[ "$item" == -* ]]; then
      debug_options+=" $item"
    fi
  done
  echo "$debug_options"
}
# hidden text in log messages
declare -a _hidden_text=()
export _hidden_text
declare -a _hidden_text_replacement=()
export _hidden_text_replacement
# indent_level - increement/decrement by one
export _logging_indent_level=0

# Function to hide sensitive text in log messages
sensitive() {
  if [[ -n "$1" ]]; then
    _hidden_text+=("$1")
    _hidden_text_replacement+=("<<${2:-hidden}>>")
  fi
}

export LOGGING_SENSITIVE_TEXT=${LOGGING_SENSITIVE_TEXT:-hide}

# Output function - prints messages to the output stream
_output() {
  local type="$1"
  shift
  local message="$*"

  # Remove hidden text
  # TODO: roll this env into DEBUG, e.g. DEBUG=abc,+sensitive,xyz
  # TODO: add script name selection in DEBUG, e.g. DEBUG=abc,script,xyz
  # TODO: also !script,!script2 means exclude
  if [[ "$LOGGING_SENSITIVE_TEXT" != "show" ]]; then
    local i
    for ((i = 0; i < ${#_hidden_text[@]}; i++)); do
      local key="${_hidden_text[$i]}"
      local value="${_hidden_text_replacement[$i]}"
      # Replace all occurrences in the message
      message="${message//$key/$value}"
    done
  fi

  # format the message
  local format
  format=$(printf "%-5s " "$type")
  # indentation is   ^ ^ always have a separating space
  if [[ -v DEBUG ]]; then
    # Debug information about execution context
    # echo "BASH_SOURCE: ${BASH_SOURCE[*]}" >&"$LOGGING_FILE_DESCRIPTOR"
    # echo "BASH_LINENO: ${BASH_LINENO[*]}" >&"$LOGGING_FILE_DESCRIPTOR"

    # if DEBUG is defined at all, we print script & line number info in clickable form
    local caller_index=1
    while [[ "$(basename "${BASH_SOURCE[$caller_index]}")" == "logging" && $caller_index -lt ${#BASH_SOURCE[@]} ]]; do
      ((caller_index++))
    done
    # echo "caller_index=$caller_index" >&"$LOGGING_FILE_DESCRIPTOR"
    if [[ $caller_index -lt ${#BASH_SOURCE[@]} ]]; then
      format+=" ${BASH_SOURCE[$caller_index]}:${BASH_LINENO[$((caller_index - 1))]}"
    else
      ((caller_index--))
      format+=" called from ${BASH_SOURCE[$caller_index]}:${BASH_LINENO[$((caller_index - 1))]}"
    fi
    # if [[ "$LOGGING_LEVEL" -ge "4" ]]; then
    #     format+=" ${FUNCNAME[1]}()"
    # fi
    format+=": "
    # Add indentation based on _logging_indent_level
    format+=$(printf '%*s' $((_logging_indent_level * 2)) "")
  fi
  local format_indent
  format_indent=$(printf "%${#format}s")
  message=${message//$'\n'/$'\n'"$format_indent"}
  # echo "$(date '+%Y-%m-%d %H:%M:%S,%3N') - $format
  echo "$format$message" >&"$LOGGING_FILE_DESCRIPTOR"
}

# Debug function - automatically detects script name and prints messages only if the script is in the DEBUG list
debug() {
  # determine script name from the calling script
  # - fallback to the current script if no caller is found
  local script_name=$(basename "${BASH_SOURCE[1]:-${BASH_SOURCE[0]}}")
  if [[ ",${DEBUG:-}," == *,"$script_name",* ]] || [[ "$BAO_BASE_VERBOSITY" -gt "3" ]]; then
    _output "DEBUG" "$*"
  fi
}

# Add a stack to track trace call depths
declare -a _trace_stack_levels=()
export _trace_stack_levels

# Define a global trace return handler
_trace_return_handler() {
  # Only process if there are items in the stack
  if [[ ${#_trace_stack_levels[@]} -gt 0 ]]; then
    # Get the last stack level we're monitoring
    local expected_level="${_trace_stack_levels[-1]}"

    # Current stack size when returning
    local current_level="${#FUNCNAME[@]}"

    # If this is the function we're tracing (stack level matches)
    if [[ "$current_level" -eq "$expected_level" ]]; then
      # Get the function name from FUNCNAME
      local context="${FUNCNAME[1]}"

      # Pop the stack by removing the last element
      unset '_trace_stack_levels[-1]'

      # Decrease indentation and log the return
      _logging_indent_level=$((_logging_indent_level - 1))
      debug "$context()."
    fi
  fi
}
export -f _trace_return_handler

# Redefine trace function to use the stack
trace() {
  local context="${FUNCNAME[1]}"
  debug "$context($*)..."
  _logging_indent_level=$((_logging_indent_level + 1))

  # Stack level is current number of functions in call stack
  # We add +1 to account for extra function call in trap execution
  _trace_stack_levels+=("$((${#FUNCNAME[@]} + 0))")

  # Set up trap to call our handler
  local old_trap=$(trap -p RETURN)
  if [[ -n "$old_trap" ]]; then
    old_trap=${old_trap#trap -- \'}
    old_trap=${old_trap%\' RETURN}
    trap "_trace_return_handler; $old_trap" RETURN
  else
    trap "_trace_return_handler" RETURN
  fi
}

outdent() {
  _logging_indent_level--
  debug "$*"
}

# Error handling function
error() {
  _output "ERROR" "$*"
  exit 1
}

warn() {
  _output "WARN" "$*"
}

# Information function based on verbosity level
# Usage: info <level> <message>
info() {
  local required_level=$1
  shift
  if [[ ${BAO_BASE_VERBOSITY:-0} -ge $required_level ]]; then
    local tag
    if [[ "$required_level" -gt 0 ]]; then
      tag="INFO$required_level"
    else
      tag="INFO"
    fi
    _output "$tag" "$*"
  fi
}

log() {
  info 0 "$@"
}

# Export the functions so they're available to child scripts
# this avoids namespace polution with helper functions
# having them there for all subscripts means that clashes are detected early
export -f _output # internal functions have to be exported too
# debug functions driven by DEBUG environment variable, which can select files to print the info on
export -f debug
export -f trace

# always printed, error also exits
export -f error
export -f warn
export -f log

# different levels of info, controlled by -v, -vv, -vvv, -vvvv on command line or imbedded in DEBUG
export -f info

# never print this text on any logging messages unless
export -f sensitive
