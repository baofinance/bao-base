#!/usr/bin/env bash
set -euo pipefail

# if [[ -n "${GUARD_SOURCING_TRANSACTING:-}" ]]; then return; fi
# GUARD_SOURCING_TRANSACTING=1
# [[ -n "${LOADING:-}" ]] && echo "loading ${BASH_SOURCE[0]}..."

# these are global variables that need to be set outside to control the transacting
export RPC_URL=""
export VERIFY=""
export BROADCAST=""
export PRIVATE_KEY=""
export ETHERSCAN_API_KEY=""
export LOCAL=""
export CHAIN_ID=""
export CHAIN_NAME=""

export forge_exe=$(command -v forge)
log "using forge at $forge_exe $(forge --version | head -n 1)."
export cast_exe=$(command -v cast)
log "using cast at $cast_exe $(cast --version | head -n 1)."

# usage _deploy_contract <purpose, e.g. implementation/proxy"> <path/to/file:contract> [<contract_name>]
_deploy_contract() {
  trace "$*"
  local purpose="$1"
  local contract_path="$2"
  local contract_name="${3:-}"
  if [[ -z "$contract_name" || "$contract_name" == -* ]]; then
    contract_name=""
    shift 2 # Only shift for purpose and contract_path
  else
    shift 3 # accept the contract name arg
  fi
  local constructor_args=("$*")

  # get the contract to deploy
  debug "Deploying $contract_path."
  local contract_type="${contract_path#*:}"
  debug "contract_type=$contract_type."
  debug "contract_name=$contract_name."

  local contract_tag
  contract_tag=${contract_name}$([[ "$contract_name" == "" ]] && echo "$contract_type" || echo " ($contract_type)")${purpose:+ $purpose}

  log "Deploying the $contract_tag contract..."

  local create_args="$contract_path"
  create_args+=" --rpc-url $RPC_URL"
  create_args+=" --private-key $PRIVATE_KEY"
  create_args+=" --etherscan-api-key $ETHERSCAN_API_KEY"
  create_args+=" $BROADCAST $VERIFY"
  create_args+=" $constructor_args"

  local response
  if ! response=$(traceit forge create $create_args); then logging fatal "forge create failed for the $contract_tag contract."; fi

  local deployer
  deployer=$(echo "$response" | awk '/Deployer:/ {print $2}')
  local address
  address=$(echo "$response" | awk '/Deployed to:/ {print $3}')
  local tx_hash
  tx_hash=$(echo "$response" | awk '/Transaction hash:/ {print $3}')

  [[ -z "$address" || -z "$tx_hash" ]] && error "Failed to deploy the $contract_tag contract."

  local block_number
  block_number=$(traceit cast tx $tx_hash --rpc-url $RPC_URL | awk '/blockNumber/ {print $2}')
  [[ -z "$block_number" ]] && error "Failed to retrieve block number for $contract_tag contract deployment."

  log "Deployed the $contract_tag contact at $address"
  log "  by $deployer tx: $tx_hash in block $block_number."

  # return the result
  local result
  result=$(jq -nc --arg address "$address" --arg tx_hash "$tx_hash" --arg block_number "$block_number" '{
        address:$address, tx_hash:$tx_hash, block_number:$block_number}')
  log "=>$result."
  echo "$result"
  # extract using jq '.address', jq '.tx_hash or jq '.block_number'
}

deploy_contract() {
  trace "$*"
  _deploy_contract "simple" "$@"
}

deploy_proxy() {
  trace "$*"
  local impl_address="$1"
  _deploy_contract 'UUPS proxy' \
    "lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol:ERC1967Proxy" \
    --constructor-args "$impl_address" '0x'
}

# transacting_deploy_upgradeable_contract() {
#   logging debug "deploy_upgreadable_contract($*)"
#   local args="$@"

#   # validate implementation

#   # deploy implementation
#   local impl
#   impl=$(_transacting_deploy_contract "implementation" "$args")
#   logging trace "impl=$impl."
#   local impl_address
#   impl_address=$(jq -r '.address' <<<"$impl")
#   logging debug "impl_address=$impl_address."

#   # save deployed data, for later validation

#   # deploy proxy
#   local proxy
#   proxy=$(_transacting_deploy_contract 'UUPS proxy' \
#     'lib/openzeppelin-contracts-upgradeable/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol:ERC1967Proxy' \
#     --constructor-args "$impl_address" '0x') || exit $?
#   logging trace "proxy=$proxy."

#   # logging info "impl=$impl"
#   # logging info "proxy=$proxy"
#   local result
#   result=$(jq -n --argjson proxy "$proxy" --argjson impl "$impl" '$proxy + {"implementation": $impl}')
#   logging trace "${FUNCNAME[0]}->$result."
#   echo "$result"
# }

confirm_deployment() {
  local contract_name=$1
  local contract_address=$2
  local deployment_block=$3
  local retry_count=0
  local current_block

  echo "Confirming deployment of $contract_name at $contract_address (Block: $deployment_block)..."

  while true; do
    current_block=$(traceit cast block latest --rpc-url $RPC_URL | awk '/number/ {print $2}')
    if [[ -n "$current_block" && "$current_block" -gt "$deployment_block" ]]; then
      echo "Contract $contract_name confirmed. Current block: $current_block"
      echo "Contract confirmed >> $contract_name: $contract_address (Confirmed in Block: $deployment_block)" >>"$OUTPUT_FILE"
      break
    fi
    if [[ $retry_count -ge $MAX_RETRIES ]]; then
      echo "Error: Contract $contract_name at $contract_address not confirmed after $MAX_RETRIES retries."
      exit 1
    fi
    echo "Waiting for contract $contract_name confirmation. Current block: $current_block. Retry $((retry_count + 1))/$MAX_RETRIES"
    sleep $RETRY_DELAY
    retry_count=$((retry_count + 1))
  done
}

function upgrade_proxy() {
  trace "$*"
  local proxy="$1"
  local implementation="$2"
  local signature="$3"
  debug "proxy=${proxy}."
  debug "implementation=${implementation}."
  debug "signature=${signature}."
  shift 3
  debug "args=$*"
  local calldata
  calldata=$(traceit cast calldata "$signature" "$@")
  send_transaction $proxy "upgradeToAndCall(address,bytes)" "$implementation" "$calldata"

  # Return the proxy address
  # echo "{\"address\":\"$proxy\", \"implementation\":\"$implementation\"}"
}
export -f upgrade_proxy

send_transaction() {
  trace "$*"
  local target_address="$1"
  local signature="$2"
  shift 2
  local calldata

  # Use the new function for traced execution
  calldata=$(traceit cast calldata $signature "$@")

  local output
  log "Sending transaction to $target_address $signature ..."
  output=$(traceit cast send \
    --rpc-url "$RPC_URL" \
    --private-key "$PRIVATE_KEY" \
    "$target_address" \
    "$calldata")

  # if [ $? -ne 0 ]; then
  #   echo "Error: Transaction to $contract_name:$target_address failed. See logs for details."
  #   echo "$output" >>"$OUTPUT_FILE"
  #   exit 1
  # fi

  # Log the transaction details without the transaction hash
  # echo "Transaction to $contract_name at $target_address >> calldata: $calldata" >>"$OUTPUT_FILE"
  # echo "Transaction to $contract_name at $target_address succeeded."
}
export -f send_transaction

# Execute a command with set -x and capture the trace output
traceit() {
  local trace_fd=3
  local fifo_file=$(mktemp -u)
  mkfifo "$fifo_file"

  # Capture all output at once instead of line by line
  cat "$fifo_file" >/tmp/trace_output.$$ &
  local cat_pid=$!

  # Redirect trace output to the FIFO
  exec {trace_fd}>"$fifo_file"
  BASH_XTRACEFD=$trace_fd

  # Run the command with tracing enabled and capture its output
  set -x
  local output
  output=$("$@")
  local ret=$?
  set +x

  # Clean up and collect trace output
  exec {trace_fd}>&-
  wait $cat_pid 2>/dev/null || true

  # Get the trace output and apply all transformations
  LOGGING_UP_LEVEL=1
  # Process the trace output to:
  # 1. Remove unwanted lines (local output, local ret=0, set +x)
  # 2. Remove +++ prefixes
  # 3. Replace "+++ output=" with "->"
  local trace_output
  trace_output=$(sed -E '
    # Remove unwanted lines completely
    /^\++ local output/d
    /^\++ local ret=0/d
    /^\++ set \+x/d
    # Replace "+++ output=" with "->"
    s/^\++ output=/->/
    # Remove +++ prefixes from remaining lines
    s/^\++ //' "/tmp/trace_output.$$")

  # Send the processed output at once to info
  info 1 "$trace_output"
  LOGGING_UP_LEVEL=0

  # remove the temp files
  rm "$fifo_file" "/tmp/trace_output.$$"

  # Return the command's output
  echo "$output"
  return $ret
}
export -f traceit

function call() {
  trace "$*"
  local args=("call")
  args+=("--rpc-url" "$RPC_URL")
  args+=("$@")
  local output
  output=$(traceit cast "${args[@]}")
  # TODO: handle more data structures tuples, structs and arrays of numbers and strings
  [[ "$output" =~ ^\".*\"$ ]] && output="${output:1:-1}" # Remove the quotes
  echo "$output"
}
